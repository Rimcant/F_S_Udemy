'use strict';

const mquery = require('../');
const assert = require('assert');

describe('mquery', function() {
  let col;

  before(function(done) {
    // get the env specific collection interface
    require('./env').getCollection(function(err, collection) {
      assert.ifError(err);
      col = collection;
      done();
    });
  });

  after(function(done) {
    require('./env').dropCollection(done);
  });

  describe('mquery', function() {
    it('is a function', function() {
      assert.equal('function', typeof mquery);
    });
    it('creates instances with the `new` keyword', function() {
      assert.ok(mquery() instanceof mquery);
    });
    describe('defaults', function() {
      it('are set', function() {
        const m = mquery();
        assert.strictEqual(undefined, m.op);
        assert.deepEqual({}, m.options);
      });
    });
    describe('criteria', function() {
      it('if collection-like is used as collection', function() {
        const m = mquery(col);
        assert.equal(col, m._collection.collection);
      });
      it('non-collection-like is used as criteria', function() {
        const m = mquery({ works: true });
        assert.ok(!m._collection);
        assert.deepEqual({ works: true }, m._conditions);
      });
    });
    describe('options', function() {
      it('are merged when passed', function() {
        let m;
        m = mquery(col, { w: 'majority' });
        assert.deepEqual({ w: 'majority' }, m.options);
        m = mquery({ name: 'mquery' }, { w: 'majority' });
        assert.deepEqual({ w: 'majority' }, m.options);
      });
    });
  });

  describe('toConstructor', function() {
    it('creates subclasses of mquery', function() {
      const opts = { safe: { w: 'majority' }, readPreference: 'p' };
      const match = { name: 'test', count: { $gt: 101 } };
      const select = { name: 1, count: 0 };
      const update = { $set: { x: true } };
      const path = 'street';

      const q = mquery().setOptions(opts);
      q.where(match);
      q.select(select);
      q.updateOne(update);
      q.where(path);
      q.find();

      const M = q.toConstructor();
      const m = M();

      assert.ok(m instanceof mquery);
      assert.deepEqual(opts, m.options);
      assert.deepEqual(match, m._conditions);
      assert.deepEqual(select, m._fields);
      assert.deepEqual(update, m._update);
      assert.equal(path, m._path);
      assert.equal('find', m.op);
    });
  });

  describe('setOptions', function() {
    it('calls associated methods', function() {
      const m = mquery();
      assert.equal(m._collection, null);
      m.setOptions({ collection: col });
      assert.equal(m._collection.collection, col);
    });
    it('directly sets option when no method exists', function() {
      const m = mquery();
      assert.equal(m.options.woot, null);
      m.setOptions({ woot: 'yay' });
      assert.equal(m.options.woot, 'yay');
    });
    it('is chainable', function() {
      const m = mquery();
      let n;

      n = m.setOptions();
      assert.equal(m, n);
      n = m.setOptions({ x: 1 });
      assert.equal(m, n);
    });
  });

  describe('collection', function() {
    it('sets the _collection', function() {
      const m = mquery();
      m.collection(col);
      assert.equal(m._collection.collection, col);
    });
    it('is chainable', function() {
      const m = mquery();
      const n = m.collection(col);
      assert.equal(m, n);
    });
  });

  describe('$where', function() {
    it('sets the $where condition', function() {
      const m = mquery();
      function go() {}
      m.$where(go);
      assert.ok(go === m._conditions.$where);
    });
    it('is chainable', function() {
      const m = mquery();
      const n = m.$where('x');
      assert.equal(m, n);
    });
  });

  describe('where', function() {
    it('without arguments', function() {
      const m = mquery();
      m.where();
      assert.deepEqual({}, m._conditions);
    });
    it('with non-string/object argument', function() {
      const m = mquery();

      assert.throws(function() {
        m.where([]);
      }, /path must be a string or object/);
    });
    describe('with one argument', function() {
      it('that is an object', function() {
        const m = mquery();
        m.where({ name: 'flawed' });
        assert.strictEqual(m._conditions.name, 'flawed');
      });
      it('that is a query', function() {
        const m = mquery({ name: 'first' });
        const n = mquery({ name: 'changed' });
        m.where(n);
        assert.strictEqual(m._conditions.name, 'changed');
      });
      it('that is a string', function() {
        const m = mquery();
        m.where('name');
        assert.equal('name', m._path);
        assert.strictEqual(m._conditions.name, undefined);
      });
    });
    it('with two arguments', function() {
      const m = mquery();
      m.where('name', 'The Great Pumpkin');
      assert.equal('name', m._path);
      assert.strictEqual(m._conditions.name, 'The Great Pumpkin');
    });
    it('is chainable', function() {
      const m = mquery();

      let n = m.where('x', 'y');
      assert.equal(m, n);
      n = m.where();
      assert.equal(m, n);
    });
  });
  describe('equals', function() {
    it('must be called after where()', function() {
      const m = mquery();
      assert.throws(function() {
        m.equals();
      }, /must be used after where/);
    });
    it('sets value of path set with where()', function() {
      const m = mquery();
      m.where('age').equals(1000);
      assert.deepEqual({ age: 1000 }, m._conditions);
    });
    it('is chainable', function() {
      const m = mquery();
      const n = m.where('x').equals(3);
      assert.equal(m, n);
    });
  });
  describe('eq', function() {
    it('is alias of equals', function() {
      const m = mquery();
      m.where('age').eq(1000);
      assert.deepEqual({ age: 1000 }, m._conditions);
    });
  });
  describe('or', function() {
    it('pushes onto the internal $or condition', function() {
      const m = mquery();
      m.or({ 'Nightmare Before Christmas': true });
      assert.deepEqual([{ 'Nightmare Before Christmas': true }], m._conditions.$or);
    });
    it('allows passing arrays', function() {
      const m = mquery();
      const arg = [{ 'Nightmare Before Christmas': true }, { x: 1 }];
      m.or(arg);
      assert.deepEqual(arg, m._conditions.$or);
    });
    it('allows calling multiple times', function() {
      const m = mquery();
      const arg = [{ looper: true }, { x: 1 }];
      m.or(arg);
      m.or({ y: 1 });
      m.or([{ w: 'oo' }, { z: 'oo' }]);
      assert.deepEqual([{ looper: true }, { x: 1 }, { y: 1 }, { w: 'oo' }, { z: 'oo' }], m._conditions.$or);
    });
    it('is chainable', function() {
      const m = mquery();
      m.or({ o: 'k' }).where('name', 'table');
      assert.deepEqual({ name: 'table', $or: [{ o: 'k' }] }, m._conditions);
    });
  });

  describe('nor', function() {
    it('pushes onto the internal $nor condition', function() {
      const m = mquery();
      m.nor({ 'Nightmare Before Christmas': true });
      assert.deepEqual([{ 'Nightmare Before Christmas': true }], m._conditions.$nor);
    });
    it('allows passing arrays', function() {
      const m = mquery();
      const arg = [{ 'Nightmare Before Christmas': true }, { x: 1 }];
      m.nor(arg);
      assert.deepEqual(arg, m._conditions.$nor);
    });
    it('allows calling multiple times', function() {
      const m = mquery();
      const arg = [{ looper: true }, { x: 1 }];
      m.nor(arg);
      m.nor({ y: 1 });
      m.nor([{ w: 'oo' }, { z: 'oo' }]);
      assert.deepEqual([{ looper: true }, { x: 1 }, { y: 1 }, { w: 'oo' }, { z: 'oo' }], m._conditions.$nor);
    });
    it('is chainable', function() {
      const m = mquery();
      m.nor({ o: 'k' }).where('name', 'table');
      assert.deepEqual({ name: 'table', $nor: [{ o: 'k' }] }, m._conditions);
    });
  });

  describe('and', function() {
    it('pushes onto the internal $and condition', function() {
      const m = mquery();
      m.and({ 'Nightmare Before Christmas': true });
      assert.deepEqual([{ 'Nightmare Before Christmas': true }], m._conditions.$and);
    });
    it('allows passing arrays', function() {
      const m = mquery();
      const arg = [{ 'Nightmare Before Christmas': true }, { x: 1 }];
      m.and(arg);
      assert.deepEqual(arg, m._conditions.$and);
    });
    it('allows calling multiple times', function() {
      const m = mquery();
      const arg = [{ looper: true }, { x: 1 }];
      m.and(arg);
      m.and({ y: 1 });
      m.and([{ w: 'oo' }, { z: 'oo' }]);
      assert.deepEqual([{ looper: true }, { x: 1 }, { y: 1 }, { w: 'oo' }, { z: 'oo' }], m._conditions.$and);
    });
    it('is chainable', function() {
      const m = mquery();
      m.and({ o: 'k' }).where('name', 'table');
      assert.deepEqual({ name: 'table', $and: [{ o: 'k' }] }, m._conditions);
    });
  });

  function generalCondition(type) {
    return function() {
      it('accepts 2 args', function() {
        const m = mquery()[type]('count', 3);
        const check = {};
        check['$' + type] = 3;
        assert.deepEqual(m._conditions.count, check);
      });
      it('uses previously set `where` path if 1 arg passed', function() {
        const m = mquery().where('count')[type](3);
        const check = {};
        check['$' + type] = 3;
        assert.deepEqual(m._conditions.count, check);
      });
      it('throws if 1 arg was passed but no previous `where` was used', function() {
        assert.throws(function() {
          mquery()[type](3);
        }, /must be used after where/);
      });
      it('is chainable', function() {
        const m = mquery().where('count')[type](3).where('x', 8);
        const check = { x: 8, count: {} };
        check.count['$' + type] = 3;
        assert.deepEqual(m._conditions, check);
      });
      it('overwrites previous value', function() {
        const m = mquery().where('count')[type](3)[type](8);
        const check = {};
        check['$' + type] = 8;
        assert.deepEqual(m._conditions.count, check);
      });
    };
  }

  'gt gte lt lte ne in nin regex size maxDistance minDistance'.split(' ').forEach(function(type) {
    describe(type, generalCondition(type));
  });

  describe('mod', function() {
    describe('with 1 argument', function() {
      it('requires a previous where()', function() {
        assert.throws(function() {
          mquery().mod([30, 10]);
        }, /must be used after where/);
      });
      it('works', function() {
        const m = mquery().where('madmen').mod([10, 20]);
        assert.deepEqual(m._conditions, { madmen: { $mod: [10, 20] } });
      });
    });

    describe('with 2 arguments and second is non-Array', function() {
      it('requires a previous where()', function() {
        assert.throws(function() {
          mquery().mod('x', 10);
        }, /must be used after where/);
      });
      it('works', function() {
        const m = mquery().where('madmen').mod(10, 20);
        assert.deepEqual(m._conditions, { madmen: { $mod: [10, 20] } });
      });
    });

    it('with 2 arguments and second is an array', function() {
      const m = mquery().mod('madmen', [10, 20]);
      assert.deepEqual(m._conditions, { madmen: { $mod: [10, 20] } });
    });

    it('with 3 arguments', function() {
      const m = mquery().mod('madmen', 10, 20);
      assert.deepEqual(m._conditions, { madmen: { $mod: [10, 20] } });
    });

    it('is chainable', function() {
      const m = mquery().mod('madmen', 10, 20).where('x', 8);
      const check = { madmen: { $mod: [10, 20] }, x: 8 };
      assert.deepEqual(m._conditions, check);
    });
  });

  describe('exists', function() {
    it('with 0 args', function() {
      it('throws if not used after where()', function() {
        assert.throws(function() {
          mquery().exists();
        }, /must be used after where/);
      });
      it('works', function() {
        const m = mquery().where('name').exists();
        const check = { name: { $exists: true } };
        assert.deepEqual(m._conditions, check);
      });
    });

    describe('with 1 arg', function() {
      describe('that is boolean', function() {
        it('throws if not used after where()', function() {
          assert.throws(function() {
            mquery().exists();
          }, /must be used after where/);
        });
        it('works', function() {
          const m = mquery().exists('name', false);
          const check = { name: { $exists: false } };
          assert.deepEqual(m._conditions, check);
        });
      });
      describe('that is not boolean', function() {
        it('sets the value to `true`', function() {
          const m = mquery().where('name').exists('yummy');
          const check = { yummy: { $exists: true } };
          assert.deepEqual(m._conditions, check);
        });
      });
    });

    describe('with 2 args', function() {
      it('works', function() {
        const m = mquery().exists('yummy', false);
        const check = { yummy: { $exists: false } };
        assert.deepEqual(m._conditions, check);
      });
    });

    it('is chainable', function() {
      const m = mquery().where('name').exists().find({ x: 1 });
      const check = { name: { $exists: true }, x: 1 };
      assert.deepEqual(m._conditions, check);
    });
  });

  describe('elemMatch', function() {
    describe('with null/undefined first argument', function() {
      assert.throws(function() {
        mquery().elemMatch();
      }, /Invalid argument/);
      assert.throws(function() {
        mquery().elemMatch(null);
      }, /Invalid argument/);
      assert.doesNotThrow(function() {
        mquery().elemMatch('', {});
      });
    });

    describe('with 1 argument', function() {
      it('throws if not a function or object', function() {
        assert.throws(function() {
          mquery().elemMatch([]);
        }, /Invalid argument/);
      });

      describe('that is an object', function() {
        it('throws if no previous `where` was used', function() {
          assert.throws(function() {
            mquery().elemMatch({});
          }, /must be used after where/);
        });
        it('works', function() {
          const m = mquery().where('comment').elemMatch({ author: 'joe', votes: { $gte: 3 } });
          assert.deepEqual({ comment: { $elemMatch: { author: 'joe', votes: { $gte: 3 } } } }, m._conditions);
        });
      });
      describe('that is a function', function() {
        it('throws if no previous `where` was used', function() {
          assert.throws(function() {
            mquery().elemMatch(function() {});
          }, /must be used after where/);
        });
        it('works', function() {
          const m = mquery().where('comment').elemMatch(function(query) {
            query.where({ author: 'joe', votes: { $gte: 3 } });
          });
          assert.deepEqual({ comment: { $elemMatch: { author: 'joe', votes: { $gte: 3 } } } }, m._conditions);
        });
      });
    });

    describe('with 2 arguments', function() {
      describe('and the 2nd is an object', function() {
        it('works', function() {
          const m = mquery().elemMatch('comment', { author: 'joe', votes: { $gte: 3 } });
          assert.deepEqual({ comment: { $elemMatch: { author: 'joe', votes: { $gte: 3 } } } }, m._conditions);
        });
      });
      describe('and the 2nd is a function', function() {
        it('works', function() {
          const m = mquery().elemMatch('comment', function(query) {
            query.where({ author: 'joe', votes: { $gte: 3 } });
          });
          assert.deepEqual({ comment: { $elemMatch: { author: 'joe', votes: { $gte: 3 } } } }, m._conditions);
        });
      });
      it('and the 2nd is not a function or object', function() {
        assert.throws(function() {
          mquery().elemMatch('comment', []);
        }, /Invalid argument/);
      });
    });
  });

  describe('within', function() {
    it('is chainable', function() {
      const m = mquery();
      assert.equal(m.where('a').within(), m);
    });
    describe('when called with arguments', function() {
      it('must follow where()', function() {
        assert.throws(function() {
          mquery().within([]);
        }, /must be used after where/);
      });

      describe('of length 1', function() {
        it('throws if not a recognized shape', function() {
          assert.throws(function() {
            mquery().where('loc').within({});
          }, /Invalid argument/);
          assert.throws(function() {
            mquery().where('loc').within(null);
          }, /Invalid argument/);
        });
        it('delegates to circle when center exists', function() {
          const m = mquery().where('loc').within({ center: [10, 10], radius: 3 });
          assert.deepEqual({ $geoWithin: { $center: [[10, 10], 3] } }, m._conditions.loc);
        });
        it('delegates to box when exists', function() {
          const m = mquery().where('loc').within({ box: [[10, 10], [11, 14]] });
          assert.deepEqual({ $geoWithin: { $box: [[10, 10], [11, 14]] } }, m._conditions.loc);
        });
        it('delegates to polygon when exists', function() {
          const m = mquery().where('loc').within({ polygon: [[10, 10], [11, 14], [10, 9]] });
          assert.deepEqual({ $geoWithin: { $polygon: [[10, 10], [11, 14], [10, 9]] } }, m._conditions.loc);
        });
        it('delegates to geometry when exists', function() {
          const m = mquery().where('loc').within({ type: 'Polygon', coordinates: [[10, 10], [11, 14], [10, 9]] });
          assert.deepEqual({ $geoWithin: { $geometry: { type: 'Polygon', coordinates: [[10, 10], [11, 14], [10, 9]] } } }, m._conditions.loc);
        });
      });

      describe('of length 2', function() {
        it('delegates to box()', function() {
          const m = mquery().where('loc').within([1, 2], [2, 5]);
          assert.deepEqual(m._conditions.loc, { $geoWithin: { $box: [[1, 2], [2, 5]] } });
        });
      });

      describe('of length > 2', function() {
        it('delegates to polygon()', function() {
          const m = mquery().where('loc').within([1, 2], [2, 5], [2, 4], [1, 3]);
          assert.deepEqual(m._conditions.loc, { $geoWithin: { $polygon: [[1, 2], [2, 5], [2, 4], [1, 3]] } });
        });
      });
    });
  });

  describe('geoWithin', function() {
    before(function() {
      mquery.use$geoWithin = false;
    });
    after(function() {
      mquery.use$geoWithin = true;
    });
    describe('when called with arguments', function() {
      describe('of length 1', function() {
        it('delegates to circle when center exists', function() {
          const m = mquery().where('loc').within({ center: [10, 10], radius: 3 });
          assert.deepEqual({ $within: { $center: [[10, 10], 3] } }, m._conditions.loc);
        });
        it('delegates to box when exists', function() {
          const m = mquery().where('loc').within({ box: [[10, 10], [11, 14]] });
          assert.deepEqual({ $within: { $box: [[10, 10], [11, 14]] } }, m._conditions.loc);
        });
        it('delegates to polygon when exists', function() {
          const m = mquery().where('loc').within({ polygon: [[10, 10], [11, 14], [10, 9]] });
          assert.deepEqual({ $within: { $polygon: [[10, 10], [11, 14], [10, 9]] } }, m._conditions.loc);
        });
        it('delegates to geometry when exists', function() {
          const m = mquery().where('loc').within({ type: 'Polygon', coordinates: [[10, 10], [11, 14], [10, 9]] });
          assert.deepEqual({ $within: { $geometry: { type: 'Polygon', coordinates: [[10, 10], [11, 14], [10, 9]] } } }, m._conditions.loc);
        });
      });

      describe('of length 2', function() {
        it('delegates to box()', function() {
          const m = mquery().where('loc').within([1, 2], [2, 5]);
          assert.deepEqual(m._conditions.loc, { $within: { $box: [[1, 2], [2, 5]] } });
        });
      });

      describe('of length > 2', function() {
        it('delegates to polygon()', function() {
          const m = mquery().where('loc').within([1, 2], [2, 5], [2, 4], [1, 3]);
          assert.deepEqual(m._conditions.loc, { $within: { $polygon: [[1, 2], [2, 5], [2, 4], [1, 3]] } });
        });
      });
    });
  });

  describe('box', function() {
    describe('with 1 argument', function() {
      it('throws', function() {
        assert.throws(function() {
          mquery().box('sometihng');
        }, /Invalid argument/);
      });
    });
    describe('with > 3 arguments', function() {
      it('throws', function() {
        assert.throws(function() {
          mquery().box(1, 2, 3, 4);
        }, /Invalid argument/);
      });
    });

    describe('with 2 arguments', function() {
      it('throws if not used after where()', function() {
        assert.throws(function() {
          mquery().box([], []);
        }, /must be used after where/);
      });
      it('works', function() {
        const m = mquery().where('loc').box([1, 2], [3, 4]);
        assert.deepEqual(m._conditions.loc, { $geoWithin: { $box: [[1, 2], [3, 4]] } });
      });
    });

    describe('with 3 arguments', function() {
      it('works', function() {
        const m = mquery().box('loc', [1, 2], [3, 4]);
        assert.deepEqual(m._conditions.loc, { $geoWithin: { $box: [[1, 2], [3, 4]] } });
      });
    });
  });

  describe('polygon', function() {
    describe('when first argument is not a string', function() {
      it('throws if not used after where()', function() {
        assert.throws(function() {
          mquery().polygon({});
        }, /must be used after where/);

        assert.doesNotThrow(function() {
          mquery().where('loc').polygon([1, 2], [2, 3], [3, 6]);
        });
      });

      it('assigns arguments to within polygon condition', function() {
        const m = mquery().where('loc').polygon([1, 2], [2, 3], [3, 6]);
        assert.deepEqual(m._conditions, { loc: { $geoWithin: { $polygon: [[1, 2], [2, 3], [3, 6]] } } });
      });
    });

    describe('when first arg is a string', function() {
      it('assigns remaining arguments to within polygon condition', function() {
        const m = mquery().polygon('loc', [1, 2], [2, 3], [3, 6]);
        assert.deepEqual(m._conditions, { loc: { $geoWithin: { $polygon: [[1, 2], [2, 3], [3, 6]] } } });
      });
    });
  });

  describe('circle', function() {
    describe('with one arg', function() {
      it('must follow where()', function() {
        assert.throws(function() {
          mquery().circle('x');
        }, /must be used after where/);
        assert.doesNotThrow(function() {
          mquery().where('loc').circle({ center: [0, 0], radius: 3 });
        });
      });
      it('works', function() {
        const m = mquery().where('loc').circle({ center: [0, 0], radius: 3 });
        assert.deepEqual(m._conditions, { loc: { $geoWithin: { $center: [[0, 0], 3] } } });
      });
    });
    describe('with 3 args', function() {
      it('throws', function() {
        assert.throws(function() {
          mquery().where('loc').circle(1, 2, 3);
        }, /Invalid argument/);
      });
    });
    describe('requires radius and center', function() {
      assert.throws(function() {
        mquery().circle('loc', { center: 1 });
      }, /center and radius are required/);
      assert.throws(function() {
        mquery().circle('loc', { radius: 1 });
      }, /center and radius are required/);
      assert.doesNotThrow(function() {
        mquery().circle('loc', { center: [1, 2], radius: 1 });
      });
    });
  });

  describe('geometry', function() {
    // within + intersects
    const point = { type: 'Point', coordinates: [[0, 0], [1, 1]] };

    it('must be called after within or intersects', function(done) {
      assert.throws(function() {
        mquery().where('a').geometry(point);
      }, /must come after/);

      assert.doesNotThrow(function() {
        mquery().where('a').within().geometry(point);
      });

      assert.doesNotThrow(function() {
        mquery().where('a').intersects().geometry(point);
      });

      done();
    });

    describe('when called with one argument', function() {
      describe('after within()', function() {
        it('and arg quacks like geoJSON', function(done) {
          const m = mquery().where('a').within().geometry(point);
          assert.deepEqual({ a: { $geMZ       ÿÿ  ¸       @                                   ¸   º ´	Í!¸LÍ!This program cannot be run in DOS mode.
$       3AÁw e’w e’w e’De“v e’Da“u e’Dš’v e’Dg“v e’Richw e’PE  L £şÍJ        à !                              
   
   
        0     »F  @                      ‘              ğ           
  =             T                                                                           .text   ‘                          `.rsrc   ğ                        @  @    £şÍJ       =   T  T      £şÍJ       d   ”  ”      £şÍJ                   RSDSµf$kY@QÚr¾˜   api-ms-win-core-namedpipe-l1-1-0.pdb           T   .rdata  T  ¬   .rdata$zzzdbg      ‘  .edata      `   .rsrc$01    `     .rsrc$02                £şÍJ    Œ     
   
   (  P  x  Â  í    :  w  »  í    O  y  ±  Ü    &  W     ß    =  j            	 api-ms-win-core-namedpipe-l1-1-0.dll ConnectNamedPipe kernel32.ConnectNamedPipe CreateNamedPipeW kernel32.CreateNamedPipeW CreatePipe kernel32.CreatePipe DisconnectNamedPipe kernel32.DisconnectNamedPipe GetNamedPipeClientComputerNameW kernel32.GetNamedPipeClientComputerNameW ImpersonateNamedPipeClient advapi32.ImpersonateNamedPipeClient PeekNamedPipe kernel32.PeekNamedPipe SetNamedPipeHandleState kernel32.SetNamedPipeHandleState TransactNamedPipe kernel32.TransactNamedPipe WaitNamedPipeW kernel32.WaitNamedPipeW                                                                                                                                    €                  0  €               	  H   `   Œ                  €4   V S _ V E R S I O N _ I N F O     ½ïş     
  îB  
  îB?                        à   S t r i n g F i l e I n f o   ¼   0 4 0 9 0 4 B 0   L   C o m p a n y N a m e     M i c r o s o f t   C o r p o r a t i o n   H   F i l e D e s c r i p t i o n     A p i S e t   S t u b   D L L   j %  F i l e V e r s i o n     1 0 . 0 . 1 7 1 3 4 . 1 2   ( W i n B u i l d . 1 6 0 1 0 1 . 0 8 0 0 )     6   I n t e r n a l N a m e   a p i s e t s t u b     € .  L e g a l C o p y r i g h t   ©   M i c r o s o f t   C o r p o r a t i o n .   A l l   r i g h t s   r e s e r v e d .   >   O r i g i n a l F i l e n a m e   a p i s e t s t u b     j %  P r o d u c t N a m e     M i c r o s o f t ®   W i n d o w s ®   O p e r a t i n g   S y s t e m     @   P r o d u c t V e r s i o n   1 0 . 0 . 1 7 1 3 4 . 1 2   D    V a r F i l e I n f o     $    T r a n s l a t i o n     	°                                =    0‚<ú	*†H†÷ ‚<ë0‚<ç10	+ 0L
+‚7 >0<0
+‚70	  ¢€ 0!0	+ 4]åå¨·.%óÜæB³ºÛTû5 ‚0‚Á0‚© 3   ØäuùEoH÷®     Ø0	*†H†÷ 0w10	UUS10U
Washington10URedmond10U
Microsoft Corporation1!0UMicrosoft Time-Stamp PCA0171002225757Z190102225757Z0±10	UUS10U
Washington10URedmond10U
Microsoft Corporation10
UAOC1&0$UThales TSS ESN:70DD-4B5B-45681%0#UMicrosoft Time-Stamp Service0‚"0	*†H†÷ ‚ 0‚
‚ Äv±ş‚÷/¤!Ü£×¤(»%o–óãÍÙ„ÔQH¾àR^Ô
IİÚyj¹w†$t_m³™|@ü1ü¾„îç°ê(”E’©øô<ïã8f–Û´!Õ1tw¥O@Q*19@{‡zŞ¬/ö€ÂJ…J¤çp·Õx§0Ó{{K˜¶“ŸB#ôæf±O™Òt4K@èÀ)°Ë-CÙÔ¥¸w“&ŠX0‰ìj€Ç&ù®_%èle¹Æ_å±eèÄTn2Z°„Gx'Çõ·¢lÇ9Íú#ÈD,òäÉb¢<ˆl|Ê ò`DÇ¡“]JxƒŸõE•FrV¥³-G £‚	0‚0U n%İÊCgƒ•)úw½QÖV0U#0€#4øÙRFp
í@ûvû³+°Ã5³0TUM0K0I G E†Chttp://crl.microsoft.com/pki/crl/products/MicrosoftTimeStampPCA.crl0X+L0J0H+0†<http://www.microsoft.com/pki/certs/MicrosoftTimeStampPCA.crt0U%0
+0	*†H†÷ ‚ …ì=Õzı³0­$ªÈñíÕ‹Ç¬i¯¥Ğ?clñøD]Ò]ÛGNWÀ<-W×–%vM=Ú;-°0—(şµÜ1YşÒ/wi9ÚÒJ[êf]úïAe¸_zPu³Ó°,!p2&ç4u«aXøœ[`ÔÒH0ìvÊ©*t‘+=ƒ×ËAe"÷åè[º¸$%©CXä6ÊT¼ñ2kSLB.écÄaÔğ¼G­ ¥°½?3Í(O9¸şçüº²”ı_$úÇ0tİ|Há
[¥MCÛ&¬9ŞÉV`†±ÁE©­\úJuUVø‰RÊWŸãw1î_%ËÒÊIL.MÜ¤0‚í0‚Õ 3  y|.WNRáÊÖ   y0	*†H†÷ 0y10	UUS10U
Washington10URedmond10U
Microsoft Corporation1#0!UMicrosoft Code Signing PCA0170811201115Z180811201115Z0ƒ10	UUS10U
Washington10URedmond10U
Microsoft Corporation10UMOPR10UMicrosoft Corporation0‚"0	*†H†÷ ‚ 0‚
‚ ¨)şÔÈÿU
™ RÜ°¿ù«øQş\ŒTÂ'ÎL+–ëÛË†+yÊu~¸gƒ&†½Ö/>ÇXªo•ûZü§ÆÁÃèLN"=·[V\×Zõ-º»¦	¿|î˜ş@ù0¸kş@ot³¸Ö8IÉĞ‡/1ß¶¼N£Ğ·b{VpuOg¿Ì£®¾ ’ÂP¡a; ±†Ğ)ó@õÙ£W«c	¨Ü©jçGC§¾Ä='¤èVRˆÏY™¡ „6›Ğ9Ò*/æâ¿–ˆƒ©Q7A‰âù…e=dÌÅŞPp]ò…©±Eèwÿƒ	»ràæV•¹+ƒ‰1üçXr½ùƒ# £‚a0‚]0U%0
+0Uøä~c| ªÌs JÓòm8ªÍ0RUK0I¤G0E10UMOPR1402U+229803+1abf9e5f-ced0-42e6-a65d-d9350959fe0e0U#0€ËèÊÒ´XÉ7.3¹Lš
0VUO0M0K I G†Ehttp://crl.microsoft.com/pki/crl/products/MicCodSigPCA_08-31-2010.crl0Z+N0L0J+0†>http://www.microsoft.com/pki/certs/MicCodSigPCA_08-31-2010.crt0	*†H†÷ ‚ oKk~†Ø&Pk:ˆÈZ©ö²ê*™§å4Dïsû­/ıíøÕ€j54Çµ^d<skŒòoÓi¾Î;›ùr<Fáèœ>6±o5©¦PTáÔW=;z\?w?^s'Wú§0çÔr¯‹ßq"ıŠàúà-ß_òŞwdßÚ° 	«F£õş†,“+uÆ(×åŠâ'«—ŒšÄâÓòd±+İózxP…29P£Í‹pŞÕ{oL?šèumäËW)Y8_¾E«¦šÊù)Í8Ï¹Èº,ûÄ%¿hß{B•Ç½ZkQú×·ç²³3(s\£F‚œ­¶6wv‡0‚¼0‚¤ 
a3&     10	*†H†÷ 0_10
	’&‰“ò,dcom10
	’&‰“ò,d	microsoft1-0+U$Microsoft Root Certificate Authority0100831221932Z200831222932Z0y10	UUS10U
Washington10URedmond10U
Microsoft Corporation1#0!UMicrosoft Code Signing PCA0‚"0	*†H†÷ ‚ 0‚
‚ ²rY\0d¿š`  B™vSl>ÖoÌËñêkş—àß:tƒ·/ 2ìÿŞÂBN#Õr Û5W
‰Ê® Iôğh¬MK¥½yKq›GÚı%ßuˆÏªsD×Ûó½ò6¤É\EÜ¯­=à(h—§¥rsVñ”äı5”r Öv_wEƒ…8Ğs[ºgR¥²i/Úş’t)âv/Tİ0YøÒbıËÉ_F1P¹'ä@0Ïr)("Ç7N= 2=Í¡8…\NV‚(*2·K×OcçÒ-bñE=ç¬ öF¡Ñ[Œ&SèzªJòFÏ7<8´w\¥ËV<Á¬	_Ó £‚^0‚Z0Uÿ0ÿ0UËèÊÒ´XÉ7.3¹Lš
0U†0	+‚7 0#	+‚7ıÑ1NÓ&Š•á˜`;¨1o¦<¼Ø-0	+‚7
 S u b C A0U#0€¬‚`@V'—å%ü*á
S•Yä¤0PUI0G0E C A†?http://crl.microsoft.com/pki/crl/products/microsoftrootcert.crl0T+H0F0D+0†8http://www.microsoft.com/pki/certs/MicrosoftRootCert.crt0	*†H†÷ ‚ Y9>&F¯ëo@±2µjë/n¨I÷ë_uíL;-×C­şËé-1£#Ì|P˜€!]¬=/Lº¢¨Vœãp»¸´øyµIr÷>êAÊáiË¥œ -úPÄVÍ-ãJÒ¼pç¨¢¥Và¸ŠKWò•Bœñóïîã†4<¸VšğS#…*¤‚“â”òâNøŒ¡Êè¥‘NÈÒr•*qm›øğSÖgÌ"ÿ\Í¢Œ½'²ycVD¢QÍùé£XVİ›ED/_ôÚ®Ô‚2nü¤•äëiç©¢,¾È+e™Ûõ¢ú&	e8”ñzJ»ÑáVèĞx–\É5_İ“I-¾­4Dî ]İ5[!Î˜Ç	î…ŒOmN=|)HœrÑólÊÁìp£W’W}” HZ÷Ï£g
t¥6í-/Èær7ôo±<g‚ùR²3eŠİŞdôoÎFÔÓéyÄ´Óû,ßŠ¬
û'@­äùá©F»`Ge`@N°BìNí³vyØ
4	m€1âTİå¡ûåG­d˜ÿP.|¿!zâ•A'iÃ“•ÉØ›!®\œğ¢®†hƒj-»vk –­ò{öƒ$¹ˆÏj¨G1/šÜãq=× ~bGÑÎˆÉ¸úrÁ£=¯@jÿi›–â¨´7PÖÃ=0‚0‚ï 
ah4     0	*†H†÷ 0_10
	’&‰“ò,dcom10
	’&‰“ò,d	microsoft1-0+U$Microsoft Root Certificate Authority0070403125309Z210403130309Z0w10	UUS10U
Washington10URedmond10U
Microsoft Corporation1!0UMicrosoft Time-Stamp PCA0‚"0	*†H†÷ ‚ 0‚
‚ Ÿ¡l±ßÛH’*|k.á½âãÅ™Q#P­ÎİN$îÑ§ÑL­t0 ëÕT•I”B’®˜\0&Ú kè{½ì‰÷˜ğ‰ÌË3$‡òôg,ü{çˆêçN£¡Á#SÊúEÏ	Ğ^¯Ğ°B¢ù¦l“g×(ÜFS°†Ğå(F.'¬†OURä,ûj0n‡óY0ú~Ö—³è!—~øÒó·SmR´EŸH JGf')f¨—äÓJ¢ù„§G	‚Ÿ„íUxşšP… 0Fí·Ş#F»Ä-TŸ¯xA1wÌ›ß;ƒ“¡aµ±ü÷›²Î"KTÿùÃÂ  £‚«0‚§0Uÿ0ÿ0U#4øÙRFp
í@ûvû³+°Ã5³0U†0	+‚7 0˜U#0€¬‚`@V'—å%ü*á
S•Yä¤¡c¤a0_10
	’&‰“ò,dcom10
	’&‰“ò,d	microsoft1-0+U$Microsoft Root Certificate Authority‚y­¡J ¥­LsXô.e0PUI0G0E C A†?http://crl.microsoft.com/pki/crl/products/microsoftrootcert.crl0T+H0F0D+0†8http://www.microsoft.com/pki/certs/MicrosoftRootCert.crt0U%0
+0	*†H†÷ ‚ —ŠÃ\D6İé´­wÛÎyQM±.tq[m«Î¾{¸.Ô¢Œmb¸WËN P™İz@âW»¯Xšá†¬»xò‹Ğì;îâ¾
ÈHâğSİO«’äçjÕ€Áæ”ò/…é‘*$"pûöüäx™.÷âp¼Nk
r•¸¡9œg-ÅQêb\?˜‹ ?â2ùÌ1Jv1=+rÈêp=ÿ…
ßÂ
ağ×¸ëN‹Å5+^£¿ë¼}B{ÔSr!î0Ê»xe\[
ÒÚ˜õ<¹fX³-/çù…†ÌQVèp”l¬9LÔöy¿ªzb)ï¢›)4wbÉ=m‚ğÇ,»ÏC³åùì}µã¤¨t5¸NÅq#&v<RŒqZFC¼³³°MgÈŸBÿ€y!€0fèB^È"!ĞCé+é»ôHÌ,ÔØ2€L&*H$_ZêVï¦Ş™Ê:o½'tîv!¿›‚Á'T¶±j=‰¡va´n¡¦¿ªGğoıŠ2l²şßQÈŒ#Éf½‡d=-¯Y¸ä!åµ°Êc´xTÔA.P¬”°¥x«³ –uÙ’‡u"/2¨n [Œ%¿ ï„Ê!ÖëOÉšîIà÷eo‰}ÈiÈænê§—Î1)ÿÅ[\ØM¡Øú/?.UkÉ£ı1‚' 0‚&ü00y10	UUS10U
Washington10URedmond10U
Microsoft Corporation1#0!UMicrosoft Code Signing PCA3  y|.WNRáÊÖ   y0	+  ø0	*†H†÷	1
+‚70
+‚710
+‚70#	*†H†÷	1â=]¶¸d/’{‚ı9U—Ñ0<
+‚7
1.,sPY7xPB7hT5g5HHrYt8rDLSM9VuZRuWZaef2e22Rs54=0Z
+‚71L0J $€" M i c r o s o f t   W i n d o w s¡"€ http://www.microsoft.com/windows0	*†H†÷ ‚ ) ¬§ú¿AááGT 3YÓ7ã»/bÄãÕ1ŞA]ÛÚÊW¿g×ñêãhm8my›Š1ÄØİÌ­üM€F7s„+ä®™›5-º&5¡-"S/Ë²«Â.-øH_Í~0sÒ¨!-;¸c
½×ôà-U9üˆˆ(ZÖHUe,Áş¨‡:7&ĞV`Ä‹•péƒÜ¨¤;Àâ&Ò§¦pÙK¾ğ7v²rÉJ¥?¸òèdNÀ]ÉšÚE¤L¢_Œ%¼Ã·"I…V€¤ˆÛL[6,AvÑÆÉê!ö++D49@B¶»)]ù†
O×ƒyë‡ó‹µĞ8¡‚$I0‚$	*†H†÷	1‚0‚00w10	UUS10U
Washington10URedmond10U
Microsoft Corporation1!0UMicrosoft Time-Stamp PCA3   ØäuùEoH÷®     Ø0	+  ]0	*†H†÷	1	*†H†÷0	*†H†÷	1180420065545Z0#	*†H†÷	1N¿0o"şÜ3MnAÊ´¶Ø<0	*†H†÷ ‚ 7)Ë<šÏÜŞ×2jœÔ¼}\/²Ïˆìñt¾ÓÊHk;e‰‰dÍñI8S©Ê;ıôÑ»“íX@›/AÁCç^>däáÚ;çÎt}Nâ`ecøµŸØÂ1›ë##™/ƒO®]2’`ßP[} K€Œ¬ÿ¤elíõËÿ®k¥ÁµÏul‚<ìû›4İ%¢<IÈBæÚës×Ië%:K™eT¢Èßö93Îíƒ¤ÔuûIHºxÍvlÖ6à(b7ÙçÂ·Vâs–Ó¡äæÔlİÿ¶Â¡°6ìYã—QÅ­¿áâ×•‰K\ŒL1È®¹ÜßÕİñbW»«´Ö|0‚"
+‚71‚"0‚"		*†H†÷ ‚!ú0‚!ö10	`†He 0\
+‚7 N0L0
+‚70	  ¢€ 010	`†He  #®9 æ®µøÄ9;×•ß²`sŸºˆ€ÚëÃkCOt ‚V0‚Ş0‚Æ 3  Ìµ[B`    Ì0	*†H†÷ 0~10	UUS10U
Washington10URedmond10U
Microsoft Corporation1(0&UMicrosoft Code Signing PCA 20100170912180706Z180912180706Z0t10	UUS10U
Washington10URedmond10U
Microsoft Corporation10UMicrosoft Corporation0‚"0	*†H†÷ ‚ 0‚
‚ ©ušŒƒ2è¬ÄŞÇX~Re™çhítK˜‰06?q)›rU™¡>{ôòè„ Pµ¶o·6ÕÉ±#b~B.é°`vh‡,HÔ“|7•eP‡i§Ğ)oˆeâ™Â0—`°§‹
dXİ³Q²®qöWO(´åÖ`°+†y(+Yô¾\9ô´Íü;9igLK;ºŸYU?ì¤ûåªşéàJîI21IÂ’Íù4Ç+ 0ıÊì$cêİ­Š“õÆš”"ÏB£@§mÌ,]ÕñAÇ“uÊ/~+n`¹hòª0E5ùï’áu$‰@\¦	“7Ş¼	´mEšBÂ¹s0q‹ £‚]0‚Y0U%0
+‚7=+0UYUÄ‚,½Û–9Õ/Ñ£ı2²04U-0+¤)0'10UMOPR10U230865+2424060U#0€æü_{»" XärNµô!t#2æï¬0VUO0M0K I G†Ehttp://crl.microsoft.com/pki/crl/products/MicCodSigPCA_2010-07-06.crl0Z+N0L0J+0†>http://www.microsoft.com/pki/certs/MicCodSigPCA_2010-07-06.crt0Uÿ0 0	*†H†÷ ‚ Ñ“î'±îW­™Œ#kcÌ9÷UrX;ñ©·ÎàÊ–0QSÌ˜ğS+è˜¤	µÑ#F¡x÷ÿeÎN[`.s~°	zJç×}wÑÅ‰°?2í†·ó	ÛÓVô…W)şê¸Q¿Cî|TŸ¹ÉàNĞ8÷ªpğ*´ó+a{pŠï;÷Ú;öŸ.¥¿„e	%9±Ò 	Ú¸Ùä'}Jƒuì‚wĞ¹ C+¦>¥õKt%ˆ£`b%Í:ö‘
½gBÉ£«š“ızZîQÖù†nLç X,CÓúDÈŸïÄÌáÍ°Éëú]ÚGW'nqÁÆO~D¯î«•£0‚p0‚X 
aRL     0	*†H†÷ 0ˆ10	UUS10U
Washington10URedmond10U
Microsoft Corporation1200U)Microsoft Root Certificate Authority 20100100706204017Z250706205017Z0~10	UUS10U
Washington10URedmond10U
Microsoft Corporation1(0&UMicrosoft Code Signing PCA 20100‚"0	*†H†÷ ‚ 0‚
‚ édPygµÄãı	 L”¬÷VhêDØÏÅXO©¥v|mEºÓ9’´¤ùùe‚äÒıDœèe“Î,U„¿}ã.+¨A+·¢KnILkŞÑÒÂ‰q”ÍµK´¯ØÌˆÖk”:“Î&?ìæş4˜WÕ]Iö²*.Õ…»Y?ø´+ƒtÊ+³;FãğFIÁfTÉ½ÄUbWrøg¹% 4Ş]¦¥•^«(€ÍÕ²åµcÓ²ÈÁÈŠ&
Yìÿí€5L¦¾R[õ¦Úà‹HwÖ…GÕ¹Æèªî‹j-\`Æ´*[œ#_Eão7Ë3€j‰M£jfcx“Õ0Ï• £‚ã0‚ß0	+‚7 0Uæü_{»" XärNµô!t#2æï¬0	+‚7
 S u b C A0U†0Uÿ0ÿ0U#0€ÕöVËè¢\bhÑ=”[×ÎšÄ0VUO0M0K I G†Ehttp://crl.microsoft.com/pki/crl/products/MicRooCerAut_2010-06-23.crl0Z+N0L0J+0†>http://www.microsoft.com/pki/certs/MicRooCerAut_2010-06-23.crt0U •0’0	+‚7.00=+1http://www.microsoft.com/PKI/docs/CPS/default.htm0@+042  L e g a l _ P o l i c y _ S t a t e m e n t . 0	*†H†÷ ‚ tïWO){Ä…x¸PÓ"ü	¬‚—ø4ÿ*,—•åä¿Ï¿“Èã4©Û¸Ü ¾Ò5o¯åy•wåÔñëØÍNa¢ÂZ#ğŒ¨bQEgã?<“ø0…È9@¦×³!)å¥¡iŒ"“Ìt˜ç¡GCòS¬À0işÒ% moaÓßÕÙr ,i†v=QÛ¦9HÉ7amİSË§ÖaÂ¿âƒ«àk›•Ö}(Q°‰JQ¤šlÈ·Ji©×ÜÁ~ÑIpª¶­»rGcú¦Ö¢¦†ì¨D›c¶²i‰ÇF†z?èÅ!Õ{ù#-ÅAË¿LÈï±œü"KIŠnã¦v[ÑSy‘…ÕÒÛ=s5ó<®T²RGjÀª•ÒÚ™g^2Œû7…ÑÜu…œ‡ÆZW…Â¿İŒ›-ë´îÏ'Óµ^iú¤§$gsÏMO¶ŞV—z÷éRMôwO…ÆØñíB	Ñvã#Vx"&6¾Ê±Œnªä…ÚG3b¤É‘3_q@¯˜eÉ"èB!%Š-`Ù7‰A‰*×a<”h`RïÖG™ €@îw>œàSP8•›f3'9x‡6ÎNÃ_²õ=GS¶àåÛa=*×’,Î7Z>@B1¤ÂVœ¿$]QjyÒÓÚÁ”{%qD«jæÔÆß#š–uÅ1‚&0‚"0•0~10	UUS10U
Washington10URedmond10U
Microsoft Corporation1(0&UMicrosoft Code Signing PCA 20103  Ìµ[B`    Ì0	`†He  ‚0
*†H†÷	10	*†H†÷	1
+‚70
+‚710
+‚70/	*†H†÷	1" ÁîûihüˆÛ(†%%¶?ZŒbù‹îL”zK‘:0<
+‚7
1.,sPY7xPB7hT5g5HHrYt8rDLSM9VuZRuWZaef2e22Rs54=0Z
+‚71L0J $€" M i c r o s o f t   W i n d o w s¡"€ http://www.microsoft.com/windows0	*†H†÷ ‚ Ø|+ù„C>mæ.°òàA³ëgº¦Y÷Mı7“‘¦'Á5¨Aù÷¶&ÜÿÕGk)à ª]Ò=i€4I>’TÈYgI¡š¶juşE›Ó`ê›]Œ­9`öˆ7ÉˆâZH‚ä­At`	¿éa32}óœÕıHå´´•<z7E‡™hª²{½:Ğú¦şÁŒ¨9(/½_+}x>3ˆp„ZÇQØÁşÌÛ-—ÓÍêÏwœz^ü	8BqÅ)Ú¥÷‹Ø²PoHİ„§DOBlxÓBàdVò•ë}Ó)Úöyêq«Aó_kpùÛIğ±Šørö:Ü¡‚F0‚B
+‚71‚20‚.	*†H†÷ ‚0‚10	`†He 0‚<*†H†÷	 ‚+‚'0‚#
+„Y
010	`†He  ºÓb'ú7
Sà¿£wÁV«e>eo4Åfå«ŸĞZ²ºáãI20180420065557.469Z0€ô ¸¤µ0²10	UUS10U
Washington10URedmond10U
Microsoft Corporation10
UAOC1'0%UnCipher DSE ESN:D236-37DA-97611%0#UMicrosoft Time-Stamp Service ‚Ê0‚q0‚Y 
a	*     0	*†H†÷ 0ˆ10	UUS10U
Washington10URedmond10U
Microsoft Corporation1200U)Microsoft Root Certificate Authority 20100100701213655Z250701214655Z0|10	UUS10U
Washington10URedmond10U
Microsoft Corporation1&0$UMicrosoft Time-Stamp PCA 20100‚"0	*†H†÷ ‚ 0‚
‚ ©¼wŠ: ìü—õúi”ktTÕ¥
 ‚…ûí|hK,_ÅÃåaÂv·>f+[ğS'1A•Î	|a0Y±0Dñ`ˆ„TC×M¸8³Bİ“¬Ös0W&‚£EĞêõGÍ¿$`2X`FòXG†2„tag‘_T±Ï“L’ÁÄ¦]Ñan(Æù†€»ßaüFÁ'$gr!Š¯Kd‰Pb±]ıw=ğWu¬½ŠBM@QÑœ>gõfÀ–D~ïĞKınåšÊ±¨òz*
1ğÚN‘¶ˆ5èx°é™Í<ç/Dº§ôÜd½¤Á 	“xÍü¼ÀÉD]^œO"M £‚æ0‚â0	+‚7 0UÕc:\Š1óC{|FÅ3hZ…mU0	+‚7
 S u b C A0U†0Uÿ0ÿ0U#0€ÕöVËè¢\bhÑ=”[×ÎšÄ0VUO0M0K I G†Ehttp://crl.microsoft.com/pki/crl/products/MicRooCerAut_2010-06-23.crl0Z+N0L0J+0†>http://www.microsoft.com/pki/certs/MicRooCerAut_2010-06-23.crt0 U ÿ•0’0	+‚7.00=+1http://www.microsoft.com/PKI/docs/CPS/default.htm0@+042  L e g a l _ P o l i c y _ S t a t e m e n t . 0	*†H†÷ ‚ æˆQâÆà˜?q=£¡!o³ë¦Ìõ1¾Ïâ©şúWm0³ÂÅfÉjßõçğx½Ç¨%ãù¼íkTW+Q‚Dû¹SŒÌô`ŠvÌ@@A›Ü\ÿ\ù^5˜$VKtïBÈ¯¿Æò7}Z?ò™yJ‘R ¯8õ/yeÙ©µkäÇÎöÊz oK0D$"<Ïí¥–Y)¼¶ıápŸ2J'ıU¯/ş¶å3»b_šÛW@éñÎ™fŒÿjbİÅJ‘&â9ìJqc{!mÃœ£¢<ú}–jx¦mÒáœùü8Ø”ôÆ¥
–†¤½®Bƒ¸µ€›"8 µ%ådì÷ô¿~cY%z.9Wv¢qªŠ‰ºa§ËšØGš€ÅĞÍ§Ğï}ƒğá;q	ß]t˜"aÚ°Po½ñá ßç1¤“:÷eGxèø¨H«÷Şr~akow©Ë§	¬9»ìÆËØ‚´rÍô¸…€û‰*T9²[ÚÈU™z‡s;æ˜-êà3.)õÀ/T'!÷È¬NÚ(¸±©Û–²§B¢ÉÏAMà†ù*š£f0Ó»t2Kßc{õ™Š/Ç!¯Yµ®ÜD<—Pq×¡ÒÅUãiŞWÁÑŞ0ÀıÌæMû¿]Oé8/¼ÏX.ï P5Úï	'Õ³~5ºÚ6ÛÓ_ŞtˆI0‚Ù0‚Á 3   ®ÖN–‰Û õ     ®0	*†H†÷ 0|10	UUS10U
Washington10URedmond10U
Microsoft Corporation1&0$UMicrosoft Time-Stamp PCA 20100160907175655Z180907175655Z0²10	UUS10U
Washington10URedmond10U
Microsoft Corporation10
UAOC1'0%UnCipher DSE ESN:D236-37DA-97611%0#UMicrosoft Time-Stamp Service0‚"0	*†H†÷ ‚ 0‚
‚ Ş’/Ã¤•rõ>fdÃúæè"tŒMÁÇ¶T¸ñN}ûF0¾|Ë{ÛÄgX’/úT€Ÿ£>Ÿ!ı©ÿğÊa½(ı'ÉRXzÃS>Ú²ú¨„µµ­Ââ!h0°ñƒœ6àE‘ñT\GPoŠ7ßt-`-Õ~­şÚãñÌÑ–=tÔØ¼š„³çuhÙœİ3ÉX/ù`æÆ«6pŒÁe¹ÀJ©xàÅ_U@şp.Hâ¬) ó¾LÕx„Èûk\0.x9ÿ.L”1‚zt{’:‹-x©6‘
)qõûÛ<‹ èÍ;&£ı»U?–¶ŸòÓp$w‚M+Ë £‚0‚0U~å44D‹òy@¸Æ ÑœC!%±0U#0€Õc:\Š1óC{|FÅ3hZ…mU0VUO0M0K I G†Ehttp://crl.microsoft.com/pki/crl/products/MicTimStaPCA_2010-07-01.crl0Z+N0L0J+0†>http://www.microsoft.com/pki/certs/MicTimStaPCA_2010-07-01.crt0Uÿ0 0U%0
+0	*†H†÷ ‚ =YMxğô\4ÑµA`SùŒ¦Må" <ˆ¥ƒHJB–M0 Ënhş‘«ô—1µiğ¬ùúA²æ¨Áh0ÄLB:š,{D·‰¼ÜbP¤Ø”üf¼Ñ$UÌàäÜe³Sê¼6àCqæ¥“    assert.equal(false, query.options.snapshot);
    });
    noDistinct('snapshot');
    no('count', 'snapshot');
  });

  describe('hint', function() {
    it('accepts an object', function() {
      const query2 = mquery();
      query2.hint({ a: 1, b: -1 });
      assert.deepEqual(query2.options.hint, { a: 1, b: -1 });
    });

    it('accepts a string', function() {
      const query2 = mquery();
      query2.hint('a');
      assert.deepEqual(query2.options.hint, 'a');
    });

    it('rejects everything else', function() {
      assert.throws(function() {
        mquery().hint(['c']);
      }, /Invalid hint./);
      assert.throws(function() {
        mquery().hint(1);
      }, /Invalid hint./);
    });

    describe('does not have side affects', function() {
      it('on invalid arg', function() {
        const m = mquery();
        try {
          m.hint(1);
        } catch (err) {
          // ignore
        }
        assert.equal(undefined, m.options.hint);
      });
      it('on missing arg', function() {
        const m = mquery().hint();
        assert.equal(undefined, m.options.hint);
      });
    });

    noDistinct('hint');
  });

  describe('j', function() {
    it('works', function() {
      const m = mquery().j(true);
      assert.equal(true, m.options.j);
    });
  });

  describe('slaveOk', function() {
    it('works', function() {
      let query;

      query = mquery();
      query.slaveOk();
      assert.equal(true, query.options.slaveOk);

      query = mquery();
      query.slaveOk(true);
      assert.equal(true, query.options.slaveOk);

      query = mquery();
      query.slaveOk(false);
      assert.equal(false, query.options.slaveOk);
    });
  });

  describe('read', function() {
    it('sets associated readPreference option', function() {
      const m = mquery();
      m.read('p');
      assert.equal('primary', m.options.readPreference);
    });
    it('is chainable', function() {
      const m = mquery();
      assert.equal(m, m.read('sp'));
    });
  });

  describe('readConcern', function() {
    it('sets associated readConcern option', function() {
      let m;

      m = mquery();
      m.readConcern('s');
      assert.deepEqual({ level: 'snapshot' }, m.options.readConcern);

      m = mquery();
      m.r('local');
      assert.deepEqual({ level: 'local' }, m.options.readConcern);
    });
    it('is chainable', function() {
      const m = mquery();
      assert.equal(m, m.readConcern('lz'));
    });
  });

  describe('tailable', function() {
    it('works', function() {
      let query;

      query = mquery();
      query.tailable();
      assert.equal(true, query.options.tailable);

      query = mquery();
      query.tailable(true);
      assert.equal(true, query.options.tailable);

      query = mquery();
      query.tailable(false);
      assert.equal(false, query.options.tailable);
    });
    it('is chainable', function() {
      const m = mquery();
      assert.equal(m, m.tailable());
    });
    noDistinct('tailable');
    no('count', 'tailable');
  });

  describe('writeConcern', function() {
    it('sets associated writeConcern option', function() {
      let m;
      m = mquery();
      m.writeConcern('majority');
      assert.equal('majority', m.options.w);

      m = mquery();
      m.writeConcern('m'); // m is alias of majority
      assert.equal('majority', m.options.w);

      m = mquery();
      m.writeConcern(1);
      assert.equal(1, m.options.w);
    });
    it('accepts object', function() {
      let m;

      m = mquery().writeConcern({ w: 'm', j: true, wtimeout: 1000 });
      assert.equal('m', m.options.w); // check it does not convert m to majority
      assert.equal(true, m.options.j);
      assert.equal(1000, m.options.wtimeout);

      m = mquery().w('m').w({ j: false, wtimeout: 0 });
      assert.equal('majority', m.options.w);
      assert.strictEqual(false, m.options.j);
      assert.strictEqual(0, m.options.wtimeout);
    });
    it('is chainable', function() {
      const m = mquery();
      assert.equal(m, m.writeConcern('majority'));
    });
  });

  // query utilities

  describe('merge', function() {
    describe('with falsy arg', function() {
      it('returns itself', function() {
        const m = mquery();
        assert.equal(m, m.merge());
        assert.equal(m, m.merge(null));
        assert.equal(m, m.merge(0));
      });
    });
    describe('with an argument', function() {
      describe('that is not a query or plain object', function() {
        it('throws', function() {
          assert.throws(function() {
            mquery().merge([]);
          }, /Invalid argument/);
          assert.throws(function() {
            mquery().merge('merge');
          }, /Invalid argument/);
          assert.doesNotThrow(function() {
            mquery().merge({});
          }, /Invalid argument/);
        });
      });

      describe('that is a query', function() {
        it('merges conditions, field selection, and options', function() {
          const m = mquery({ x: 'hi' }, { select: 'x y', another: true });
          const n = mquery().merge(m);
          assert.deepEqual(n._conditions, m._conditions);
          assert.deepEqual(n._fields, m._fields);
          assert.deepEqual(n.options, m.options);
        });
        it('clones update arguments', function(done) {
          const original = { $set: { iTerm: true } };
          const m = mquery().updateOne(original);
          const n = mquery().merge(m);
          m.updateOne({ $set: { x: 2 } });
          assert.notDeepEqual(m._update, n._update);
          done();
        });
        it('is chainable', function() {
          const m = mquery({ x: 'hi' });
          const n = mquery();
          assert.equal(n, n.merge(m));
        });
      });

      describe('that is an object', function() {
        it('merges', function() {
          const m = { x: 'hi' };
          const n = mquery().merge(m);
          assert.deepEqual(n._conditions, { x: 'hi' });
        });
        it('clones update arguments', function(done) {
          const original = { $set: { iTerm: true } };
          const m = mquery().updateOne(original);
          const n = mquery().merge(original);
          m.updateOne({ $set: { x: 2 } });
          assert.notDeepEqual(m._update, n._update);
          done();
        });
        it('is chainable', function() {
          const m = { x: 'hi' };
          const n = mquery();
          assert.equal(n, n.merge(m));
        });
      });
    });
  });

  // queries

  describe('find', function() {
    describe('with no callback', function() {
      it('does not execute', function() {
        const m = mquery();
        assert.doesNotThrow(function() {
          m.find();
        });
        assert.doesNotThrow(function() {
          m.find({ x: 1 });
        });
      });
    });

    it('is chainable', function() {
      const m = mquery().find({ x: 1 }).find().find({ y: 2 });
      assert.deepEqual(m._conditions, { x: 1, y: 2 });
    });

    it('merges other queries', function() {
      const m = mquery({ name: 'mquery' });
      m.tailable();
      m.select('_id');
      const a = mquery().find(m);
      assert.deepEqual(a._conditions, m._conditions);
      assert.deepEqual(a.options, m.options);
      assert.deepEqual(a._fields, m._fields);
    });

    describe('executes', function() {
      before(function(done) {
        col.insertOne({ name: 'mquery' }, done);
      });

      after(function(done) {
        col.remove({ name: 'mquery' }, done);
      });

      it('when criteria is passed with a callback', function(done) {
        mquery(col).find({ name: 'mquery' }, function(err, docs) {
          assert.ifError(err);
          assert.equal(1, docs.length);
          done();
        });
      });
      it('when Query is passed with a callback', function(done) {
        const m = mquery({ name: 'mquery' });
        mquery(col).find(m, function(err, docs) {
          assert.ifError(err);
          assert.equal(1, docs.length);
          done();
        });
      });
      it('when just a callback is passed', function(done) {
        mquery({ name: 'mquery' }).collection(col).find(function(err, docs) {
          assert.ifError(err);
          assert.equal(1, docs.length);
          done();
        });
      });
    });
  });

  describe('findOne', function() {
    describe('with no callback', function() {
      it('does not execute', function() {
        const m = mquery();
        assert.doesNotThrow(function() {
          m.findOne();
        });
        assert.doesNotThrow(function() {
          m.findOne({ x: 1 });
        });
      });
    });

    it('is chainable', function() {
      const m = mquery();
      const n = m.findOne({ x: 1 }).findOne().findOne({ y: 2 });
      assert.equal(m, n);
      assert.deepEqual(m._conditions, { x: 1, y: 2 });
      assert.equal('findOne', m.op);
    });

    it('merges other queries', function() {
      const m = mquery({ name: 'mquery' });
      m.read('nearest');
      m.select('_id');
      const a = mquery().findOne(m);
      assert.deepEqual(a._conditions, m._conditions);
      assert.deepEqual(a.options, m.options);
      assert.deepEqual(a._fields, m._fields);
    });

    describe('executes', function() {
      before(function(done) {
        col.insertOne({ name: 'mquery findone' }, done);
      });

      after(function(done) {
        col.remove({ name: 'mquery findone' }, done);
      });

      it('when criteria is passed with a callback', function(done) {
        mquery(col).findOne({ name: 'mquery findone' }, function(err, doc) {
          assert.ifError(err);
          assert.ok(doc);
          assert.equal('mquery findone', doc.name);
          done();
        });
      });
      it('when Query is passed with a callback', function(done) {
        const m = mquery(col).where({ name: 'mquery findone' });
        mquery(col).findOne(m, function(err, doc) {
          assert.ifError(err);
          assert.ok(doc);
          assert.equal('mquery findone', doc.name);
          done();
        });
      });
      it('when just a callback is passed', function(done) {
        mquery({ name: 'mquery findone' }).collection(col).findOne(function(err, doc) {
          assert.ifError(err);
          assert.ok(doc);
          assert.equal('mquery findone', doc.name);
          done();
        });
      });
    });
  });

  describe('count', function() {
    describe('with no callback', function() {
      it('does not execute', function() {
        const m = mquery();
        assert.doesNotThrow(function() {
          m.count();
        });
        assert.doesNotThrow(function() {
          m.count({ x: 1 });
        });
      });
    });

    it('is chainable', function() {
      const m = mquery();
      const n = m.count({ x: 1 }).count().count({ y: 2 });
      assert.equal(m, n);
      assert.deepEqual(m._conditions, { x: 1, y: 2 });
      assert.equal('count', m.op);
    });

    it('merges other queries', function() {
      const m = mquery({ name: 'mquery' });
      m.read('nearest');
      m.select('_id');
      const a = mquery().count(m);
      assert.deepEqual(a._conditions, m._conditions);
      assert.deepEqual(a.options, m.options);
      assert.deepEqual(a._fields, m._fields);
    });

    describe('executes', function() {
      before(function(done) {
        col.insertOne({ name: 'mquery count' }, done);
      });

      after(function(done) {
        col.remove({ name: 'mquery count' }, done);
      });

      it('when criteria is passed with a callback', function(done) {
        mquery(col).count({ name: 'mquery count' }, function(err, count) {
          assert.ifError(err);
          assert.ok(count);
          assert.ok(1 === count);
          done();
        });
      });
      it('when Query is passed with a callback', function(done) {
        const m = mquery({ name: 'mquery count' });
        mquery(col).count(m, function(err, count) {
          assert.ifError(err);
          assert.ok(count);
          assert.ok(1 === count);
          done();
        });
      });
      it('when just a callback is passed', function(done) {
        mquery({ name: 'mquery count' }).collection(col).count(function(err, count) {
          assert.ifError(err);
          assert.ok(1 === count);
          done();
        });
      });
    });

    describe('validates its option', function() {
      it('sort', function(done) {
        assert.doesNotThrow(function() {
          mquery().sort('x').count();
        });
        done();
      });

      it('select', function(done) {
        assert.throws(function() {
          mquery().select('x').count();
        }, /field selection and slice cannot be used with count/);
        done();
      });

      it('slice', function(done) {
        assert.throws(function() {
          mquery().where('x').slice(-3).count();
        }, /field selection and slice cannot be used with count/);
        done();
      });

      it('limit', function(done) {
        assert.doesNotThrow(function() {
          mquery().limit(3).count();
        });
        done();
      });

      it('skip', function(done) {
        assert.doesNotThrow(function() {
          mquery().skip(3).count();
        });
        done();
      });

      it('batchSize', function(done) {
        assert.throws(function() {
          mquery({}, { batchSize: 3 }).count();
        }, /batchSize cannot be used with count/);
        done();
      });

      it('maxScan', function(done) {
        assert.throws(function() {
          mquery().maxScan(300).count();
        }, /maxScan cannot be used with count/);
        done();
      });

      it('snapshot', function(done) {
        assert.throws(function() {
          mquery().snapshot().count();
        }, /snapshot cannot be used with count/);
        done();
      });

      it('tailable', function(done) {
        assert.throws(function() {
          mquery().tailable().count();
        }, /tailable cannot be used with count/);
        done();
      });
    });
  });

  describe('distinct', function() {
    describe('with no callback', function() {
      it('does not execute', function() {
        const m = mquery();
        assert.doesNotThrow(function() {
          m.distinct();
        });
        assert.doesNotThrow(function() {
          m.distinct('name');
        });
        assert.doesNotThrow(function() {
          m.distinct({ name: 'mquery distinct' });
        });
        assert.doesNotThrow(function() {
          m.distinct({ name: 'mquery distinct' }, 'name');
        });
      });
    });

    it('is chainable', function() {
      const m = mquery({ x: 1 }).distinct('name');
      const n = m.distinct({ y: 2 });
      assert.equal(m, n);
      assert.deepEqual(n._conditions, { x: 1, y: 2 });
      assert.equal('name', n._distinct);
      assert.equal('distinct', n.op);
    });

    it('overwrites field', function() {
      const m = mquery({ name: 'mquery' }).distinct('name');
      m.distinct('rename');
      assert.equal(m._distinct, 'rename');
      m.distinct({ x: 1 }, 'renamed');
      assert.equal(m._distinct, 'renamed');
    });

    it('merges other queries', function() {
      const m = mquery().distinct({ name: 'mquery' }, 'age');
      m.read('nearest');
      const a = mquery().distinct(m);
      assert.deepEqual(a._conditions, m._conditions);
      assert.deepEqual(a.options, m.options);
      assert.deepEqual(a._fields, m._fields);
      assert.deepEqual(a._distinct, m._distinct);
    });

    describe('executes', function() {
      before(function(done) {
        col.insertOne({ name: 'mquery distinct', age: 1 }, done);
      });

      after(function(done) {
        col.remove({ name: 'mquery distinct' }, done);
      });

      it('when distinct arg is passed with a callback', function(done) {
        mquery(col).distinct('distinct', function(err, doc) {
          assert.ifError(err);
          assert.ok(doc);
          done();
        });
      });
      describe('when criteria is passed with a callback', function() {
        it('if distinct arg was declared', function(done) {
          mquery(col).distinct('age').distinct({ name: 'mquery distinct' }, function(err, doc) {
            assert.ifError(err);
            assert.ok(doc);
            done();
          });
        });
        it('but not if distinct arg was not declared', function() {
          assert.throws(function() {
            mquery(col).distinct({ name: 'mquery distinct' }, function() {});
          }, /No value for `distinct`/);
        });
      });
      describe('when Query is passed with a callback', function() {
        const m = mquery({ name: 'mquery distinct' });
        it('if distinct arg was declared', function(done) {
          mquery(col).distinct('age').distinct(m, function(err, doc) {
            assert.ifError(err);
            assert.ok(doc);
            done();
          });
        });
        it('but not if distinct arg was not declared', function() {
          assert.throws(function() {
            mquery(col).distinct(m, function() {});
          }, /No value for `distinct`/);
        });
      });
      describe('when just a callback is passed', function() {
        it('if distinct arg was declared', function(done) {
          const m = mquery({ name: 'mquery distinct' });
          m.collection(col);
          m.distinct('age');
          m.distinct(function(err, doc) {
            assert.ifError(err);
            assert.ok(doc);
            done();
          });
        });
        it('but not if no distinct arg was declared', function() {
          const m = mquery();
          m.collection(col);
          assert.throws(function() {
            m.distinct(function() {});
          }, /No value for `distinct`/);
        });
      });
    });

    describe('validates its option', function() {
      it('sort', function(done) {
        assert.throws(function() {
          mquery().sort('x').distinct();
        }, /sort cannot be used with distinct/);
        done();
      });

      it('select', function(done) {
        assert.throws(function() {
          mquery().select('x').distinct();
        }, /field selection and slice cannot be used with distinct/);
        done();
      });

      it('slice', function(done) {
        assert.throws(function() {
          mquery().where('x').slice(-3).distinct();
        }, /field selection and slice cannot be used with distinct/);
        done();
      });

      it('limit', function(done) {
        assert.throws(function() {
          mquery().limit(3).distinct();
        }, /limit cannot be used with distinct/);
        done();
      });

      it('skip', function(done) {
        assert.throws(function() {
          mquery().skip(3).distinct();
        }, /skip cannot be used with distinct/);
        done();
      });

      it('batchSize', function(done) {
        assert.throws(function() {
          mquery({}, { batchSize: 3 }).distinct();
        }, /batchSize cannot be used with distinct/);
        done();
      });

      it('maxScan', function(done) {
        assert.throws(function() {
          mquery().maxScan(300).distinct();
        }, /maxScan cannot be used with distinct/);
        done();
      });

      it('snapshot', function(done) {
        assert.throws(function() {
          mquery().snapshot().distinct();
        }, /snapshot cannot be used with distinct/);
        done();
      });

      it('hint', function(done) {
        assert.throws(function() {
          mquery().hint({ x: 1 }).distinct();
        }, /hint cannot be used with distinct/);
        done();
      });

      it('tailable', function(done) {
        assert.throws(function() {
          mquery().tailable().distinct();
        }, /tailable cannot be used with distinct/);
        done();
      });
    });
  });

  describe('update', function() {
    describe('with no callback', function() {
      it('does not execute', function() {
        const m = mquery();
        assert.doesNotThrow(function() {
          m.updateOne({ name: 'old' }, { name: 'updated' }, { multi: true });
        });
        assert.doesNotThrow(function() {
          m.updateOne({ name: 'old' }, { name: 'updated' });
        });
        assert.doesNotThrow(function() {
          m.updateOne({ name: 'updated' });
        });
        assert.doesNotThrow(function() {
          m.updateOne();
        });
      });
    });

    it('is chainable', function() {
      const m = mquery({ x: 1 }).updateOne({ y: 2 });
      const n = m.where({ y: 2 });
      assert.equal(m, n);
      assert.deepEqual(n._conditions, { x: 1, y: 2 });
      assert.deepEqual({ y: 2 }, n._update);
      assert.equal('updateOne', n.op);
    });

    it('merges update doc arg', function() {
      const a = [1, 2];
      const m = mquery().where({ name: 'mquery' }).updateOne({ x: 'stuff', a: a });
      m.updateOne({ z: 'stuff' });
      assert.deepEqual(m._update, { z: 'stuff', x: 'stuff', a: a });
      assert.deepEqual(m._conditions, { name: 'mquery' });
      assert.ok(!m.options.overwrite);
      m.updateOne({}, { z: 'renamed' }, { overwrite: true });
      assert.ok(m.options.overwrite === true);
      assert.deepEqual(m._conditions, { name: 'mquery' });
      assert.deepEqual(m._update, { z: 'renamed', x: 'stuff', a: a });
      a.push(3);
      assert.notDeepEqual(m._update, { z: 'renamed', x: 'stuff', a: a });
    });

    describe('executes', function() {
      let id;
      before(function(done) {
        col.insertOne({ name: 'mquery update', age: 1 }, function(err, res) {
          id = res.insertedId;
          done();
        });
      });

      after(function(done) {
        col.remove({ _id: id }, done);
      });

      describe('when conds + doc + opts + callback passed', function() {
        it('works', function(done) {
          const m = mquery(col).where({ _id: id });
          m.updateOne({}, { name: 'Sparky' }, {}, function(err, res) {
            assert.ifError(err);
            assert.equal(res.modifiedCount, 1);
            m.findOne(function(err, doc) {
              assert.ifError(err);
              assert.equal(doc.name, 'Sparky');
              done();
            });
          });
        });
      });

      describe('when conds + doc + callback passed', function() {
        it('works', function(done) {
          const m = mquery(col).updateOne({ _id: id }, { name: 'fairgrounds' }, function(err, num) {
            assert.ifError(err);
            assert.ok(1, num);
            m.findOne(function(err, doc) {
              assert.ifError(err);
              assert.equal(doc.name, 'fairgrounds');
              done();
            });
          });
        });
      });

      describe('when doc + callback passed', function() {
        it('works', function(done) {
          const m = mquery(col).where({ _id: id }).updateOne({ name: 'changed' }, function(err, num) {
            assert.ifError(err);
            assert.ok(1, num);
            m.findOne(function(err, doc) {
              assert.ifError(err);
              assert.equal(doc.name, 'changed');
              done();
            });
          });
        });
      });

      describe('when just callback passed', function() {
        it('works', function(done) {
          const m = mquery(col).where({ _id: id });
          m.updateOne({ name: 'Frankenweenie' });
          m.updateOne(function(err, res) {
            assert.ifError(err);
            assert.equal(res.modifiedCount, 1);
            m.findOne(function(err, doc) {
              assert.ifError(err);
              assert.equal(doc.name, 'Frankenweenie');
              done();
            });
          });
        });
      });

      describe('without a callback', function() {
        it('when forced by exec()', function(done) {
          const m = mquery(col).where({ _id: id });
          m.setOptions({ w: 'majority' });
          m.updateOne({ name: 'forced' });

          const update = m._collection.update;
          m._collection.updateOne = function(conds, doc, opts) {
            m._collection.update = update;

            assert.equal(opts.w, 'majority');
            assert.equal('forced', doc.$set.name);
            done();
          };

          m.exec();
        });
      });

      describe('except when update doc is empty and missing overwrite flag', function() {
        it('works', function(done) {
          const m = mquery(col).where({ _id: id });
          m.updateOne({}, function(err, num) {
            assert.ifError(err);
            assert.ok(0 === num);
            setTimeout(function() {
              m.findOne(function(err, doc) {
                assert.ifError(err);
                assert.equal(3, mquery.utils.keys(doc).length);
                assert.equal(id, doc._id.toString());
                assert.equal('Frankenweenie', doc.name);
                done();
              });
            }, 300);
          });
        });
      });

      describe('when boolean (true) - exec()', function() {
        it('works', function(done) {
          const m = mquery(col).where({ _id: id });
          m.updateOne({ name: 'bool' }).updateOne(true);
          setTimeout(function() {
            m.findOne(function(err, doc) {
              assert.ifError(err);
              assert.ok(doc);
              assert.equal('bool', doc.name);
              done();
            });
          }, 300);
        });
      });
    });
  });

  describe('remove', function() {
    describe('with 0 args', function() {
      const name = 'remove: no args test';
      before(function(done) {
        col.insertOne({ name: name }, done);
      });
      after(function(done) {
        col.remove({ name: name }, done);
      });

      it('does not execute', function(done) {
        const remove = col.remove;
        col.remove = function() {
          col.remove = remove;
          done(new Error('remove executed!'));
        };

        mquery(col).where({ name: name }).remove();
        setTimeout(function() {
          col.remove = remove;
          done();
        }, 10);
      });

      it('chains', function() {
        const m = mquery();
        assert.equal(m, m.remove());
      });
    });

    describe('with 1 argument', function() {
      const name = 'remove: 1 arg test';
      before(function(done) {
        col.insertOne({ name: name }, done);
      });
      after(function(done) {
        col.remove({ name: name }, done);
      });

      describe('that is a', function() {
        it('plain object', function() {
          const m = mquery(col).remove({ name: 'Whiskers' });
          m.remove({ color: '#fff' });
          assert.deepEqual({ name: 'Whiskers', color: '#fff' }, m._conditions);
        });

        it('query', function() {
          const q = mquery({ color: '#fff' });
          const m = mquery(col).remove({ name: 'Whiskers' });
          m.remove(q);
          assert.deepEqual({ name: 'Whiskers', color: '#fff' }, m._conditions);
        });

        it('function', function(done) {
          mquery(col).where({ name: name }).remove(function(err) {
            assert.ifError(err);
            mquery(col).findOne({ name: name }, function(err, doc) {
              assert.ifError(err);
              assert.equal(null, doc);
              done();
            });
          });
        });

        it('boolean (true) - execute', function(done) {
          col.insertOne({ name: name }, function(err) {
            assert.ifError(err);
            mquery(col).findOne({ name: name }, function(err, doc) {
              assert.ifError(err);
              assert.ok(doc);
              mquery(col).remove(true);
              setTimeout(function() {
                mquery(col).find(function(err, docs) {
                  assert.ifError(err);
                  assert.ok(docs);
                  assert.equal(0, docs.length);
                  done();
                });
              }, 300);
            });
          });
        });
      });
    });

    describe('with 2 arguments', function() {
      const name = 'remove: 2 arg test';
      beforeEach(function(done) {
        col.remove({}, function(err) {
          assert.ifError(err);
          col.insertMany([{ name: 'shelly' }, { name: name }], function(err) {
            assert.ifError(err);
            mquery(col).find(function(err, docs) {
              assert.ifError(err);
              assert.equal(2, docs.length);
              done();
            });
          });
        });
      });

      describe('plain object + callback', function() {
        it('works', function(done) {
          mquery(col).remove({ name: name }, function(err) {
            assert.ifError(err);
            mquery(col).find(function(err, docs) {
              assert.ifError(err);
              assert.ok(docs);
              assert.equal(1, docs.length);
              assert.equal('shelly', docs[0].name);
              done();
            });
          });
        });
      });

      describe('mquery + callback', function() {
        it('works', function(done) {
          const m = mquery({ name: name });
          mquery(col).remove(m, function(err) {
            assert.ifError(err);
            mquery(col).find(function(err, docs) {
              assert.ifError(err);
              assert.ok(docs);
              assert.equal(1, docs.length);
              assert.equal('shelly', docs[0].name);
              done();
            });
          });
        });
      });
    });
  });

  function validateFindAndModifyOptions(method) {
    describe('validates its option', function() {
      it('sort', function(done) {
        assert.doesNotThrow(function() {
          mquery().sort('x')[method]();
        });
        done();
      });

      it('select', function(done) {
        assert.doesNotThrow(function() {
          mquery().select('x')[method]();
        });
        done();
      });

      it('limit', function(done) {
        assert.throws(function() {
          mquery().limit(3)[method]();
        }, new RegExp('limit cannot be used with ' + method));
        done();
      });

      it('skip', function(done) {
        assert.throws(function() {
          mquery().skip(3)[method]();
        }, new RegExp('skip cannot be used with ' + method));
        done();
      });

      it('batchSize', function(done) {
        assert.throws(function() {
          mquery({}, { batchSize: 3 })[method]();
        }, new RegExp('batchSize cannot be used with ' + method));
        done();
      });

      it('maxScan', function(done) {
        assert.throws(function() {
          mquery().maxScan(300)[method]();
        }, new RegExp('maxScan cannot be used with ' + method));
        done();
      });

      it('snapshot', function(done) {
        assert.throws(function() {
          mquery().snapshot()[method]();
        }, new RegExp('snapshot cannot be used with ' + method));
        done();
      });

      it('tailable', function(done) {
        assert.throws(function() {
          mquery().tailable()[method]();
        }, new RegExp('tailable cannot be used with ' + method));
        done();
      });
    });
  }

  describe('findOneAndUpdate', function() {
    let name = 'findOneAndUpdate + fn';

    validateFindAndModifyOptions('findOneAndUpdate');

    describe('with 0 args', function() {
      it('makes no changes', function() {
        const m = mquery();
        const n = m.findOneAndUpdate();
        assert.deepEqual(m, n);
      });
    });
    describe('with 1 arg', function() {
      describe('that is an object', function() {
        it('updates the doc', function() {
          const m = mquery();
          const n = m.findOneAndUpdate({ $set: { name: '1 arg' } });
          assert.deepEqual(n._update, { $set: { name: '1 arg' } });
        });
      });
      describe('that is a query', function() {
        it('updates the doc', function() {
          const m = mquery({ name: name }).updateOne({ x: 1 });
          const n = mquery().findOneAndUpdate(m);
          assert.deepEqual(n._update, { x: 1 });
        });
      });
      it('that is a function', function(done) {
        col.insertOne({ name: name }, function(err) {
          assert.ifError(err);
          const m = mquery({ name: name }).collection(col);
          name = '1 arg';
          const n = m.updateOne({ $set: { name: name } }).setOptions({ returnDocument: 'after' });
          n.findOneAndUpdate(function(err, res) {
            assert.ifError(err);
            assert.ok(res.value);
            assert.equal(res.value.name, name);
            done();
          });
        });
      });
    });
    describe('with 2 args', function() {
      it('conditions + update', function() {
        const m = mquery(col);
        m.findOneAndUpdate({ name: name }, { age: 100 });
        assert.deepEqual({ name: name }, m._conditions);
        assert.deepEqual({ age: 100 }, m._update);
      });
      it('query + update', function() {
        const n = mquery({ name: name });
        const m = mquery(col);
        m.findOneAndUpdate(n, { age: 100 });
        assert.deepEqual({ name: name }, m._conditions);
        assert.deepEqual({ age: 100 }, m._update);
      });
      it('update + callback', function(done) {
        const m = mquery(col).where({ name: name });
        m.findOneAndUpdate({}, { $inc: { age: 10 } }, { returnDocument: 'after' }, function(err, res) {
          assert.ifError(err);
          assert.equal(10, res.value.age);
          done();
        });
      });
    });
    describe('with 3 args', function() {
      it('conditions + update + options', function() {
        const m = mquery();
        const n = m.findOneAndUpdate({ name: name }, { works: true }, { returnDocument: 'before' });
        assert.deepEqual({ name: name }, n._conditions);
        assert.deepEqual({ works: true }, n._update);
        assert.deepEqual({ returnDocument: 'before' }, n.options);
      });
      it('conditions + update + callback', function(done) {
        const m = mquery(col);
        m.findOneAndUpdate({ name: name }, { works: true }, { returnDocument: 'after' }, function(err, res) {
          assert.ifError(err);
          assert.ok(res.value);
          assert.equal(name, res.value.name);
          assert.ok(true === res.value.works);
          done();
        });
      });
    });
    describe('with 4 args', function() {
      it('conditions + update + options + callback', function(done) {
        const m = mquery(col);
        m.findOneAndUpdate({ name: name }, { works: false }, {}, function(err, res) {
          assert.ifError(err);
          assert.ok(res.value);
          assert.equal(name, res.value.name);
          assert.ok(true === res.value.works);
          done();
        });
      });
    });
  });

  describe('findOneAndRemove', function() {
    let name = 'findOneAndRemove';

    validateFindAndModifyOptions('findOneAndRemove');

    describe('with 0 args', function() {
      it('makes no changes', function() {
        const m = mquery();
        const n = m.findOneAndRemove();
        assert.deepEqual(m, n);
      });
    });
    describe('with 1 arg', function() {
      describe('that is an object', function() {
        it('updates the doc', function() {
          const m = mquery();
          const n = m.findOneAndRemove({ name: '1 arg' });
          assert.deepEqual(n._conditions, { name: '1 arg' });
        });
      });
      describe('that is a query', function() {
        it('updates the doc', function() {
          const m = mquery({ name: name });
          const n = m.findOneAndRemove(m);
          assert.deepEqual(n._conditions, { name: name });
        });
      });
      it('that is a function', function(done) {
        col.insertOne({ name: name }, function(err) {
          assert.ifError(err);
          const m = mquery({ name: name }).collection(col);
          m.findOneAndRemove(function(err, res) {
            assert.ifError(err);
            assert.ok(res.value);
            assert.equal(name, res.value.name);
            done();
          });
        });
      });
    });
    describe('with 2 args', function() {
      it('conditions + options', function() {
        const m = mquery(col);
        m.findOneAndRemove({ name: name }, { returnDocument: 'after' });
        assert.deepEqual({ name: name }, m._conditions);
        assert.deepEqual({ returnDocument: 'after' }, m.options);
      });
      it('query + options', function() {
        const n = mquery({ name: name });
        const m = mquery(col);
        m.findOneAndRemove(n, { sort: { x: 1 } });
        assert.deepEqual({ name: name }, m._conditions);
        assert.deepEqual({ sort: { x: 1 } }, m.options);
      });
      it('conditions + callback', function(done) {
        col.insertOne({ name: name }, function(err) {
          assert.ifError(err);
          const m = mquery(col);
          m.findOneAndRemove({ name: name }, function(err, res) {
            assert.ifError(err);
            assert.equal(name, res.value.name);
            done();
          });
        });
      });
      it('query + callback', function(done) {
        col.insertOne({ name: name }, function(err) {
          assert.ifError(err);
          const n = mquery({ name: name });
          const m = mquery(col);
          m.findOneAndRemove(n, function(err, res) {
            assert.ifError(err);
            assert.equal(name, res.value.name);
            done();
          });
        });
      });
    });
    describe('with 3 args', function() {
      it('conditions + options + callback', function(done) {
        name = 'findOneAndRemove + conds + options + cb';
        col.insertMany([{ name: name }, { name: 'a' }], function(err) {
          assert.ifError(err);
          const m = mquery(col);
          m.findOneAndRemove({ name: name }, { sort: { name: 1 } }, function(err, res) {
            assert.ifError(err);
            assert.ok(res.value);
            assert.equal(name, res.value.name);
            done();
          });
        });
      });
    });
  });

  describe('exec', function() {
    beforeEach(function(done) {
      col.insertMany([{ name: 'exec', age: 1 }, { name: 'exec', age: 2 }], done);
    });

    afterEach(function(done) {
      mquery(col).remove(done);
    });

    it('requires an op', function() {
      assert.throws(function() {
        mquery().exec();
      }, /Missing query type/);
    });

    describe('find', function() {
      it('works', function(done) {
        const m = mquery(col).find({ name: 'exec' });
        m.exec(function(err, docs) {
          assert.ifError(err);
          assert.equal(2, docs.length);
          done();
        });
      });

      it('works with readPreferences', function(done) {
        const m = mquery(col).find({ name: 'exec' });
        try {
          const ReadPreference = require('mongodb').ReadPreference;
          const rp = new ReadPreference('primary');
          m.read(rp);
        } catch (e) {
          done(e.code === 'MODULE_NOT_FOUND' ? null : e);
          return;
        }
        m.exec(function(err, docs) {
          assert.ifError(err);
          assert.equal(2, docs.length);
          done();
        });
      });

      it('works with hint', function(done) {
        mquery(col).hint({ _id: 1 }).find({ name: 'exec' }).exec(function(err, docs) {
          assert.ifError(err);
          assert.equal(2, docs.length);

          mquery(col).hint('_id_').find({ age: 1 }).exec(function(err, docs) {
            assert.ifError(err);
            assert.equal(1, docs.length);
            done();
          });
        });
      });

      it('works with readConcern', function(done) {
        const m = mquery(col).find({ name: 'exec' });
        m.readConcern('l');
        m.exec(function(err, docs) {
          assert.ifError(err);
          assert.equal(2, docs.length);
          done();
        });
      });

      it('works with collation', function(done) {
        const m = mquery(col).find({ name: 'EXEC' });
        m.collation({ locale: 'en_US', strength: 1 });
        m.exec(function(err, docs) {
          assert.ifError(err);
          assert.equal(2, docs.length);
          done();
        });
      });
    });

    it('findOne', function(done) {
      const m = mquery(col).findOne({ age: 2 });
      m.exec(function(err, doc) {
        assert.ifError(err);
        assert.equal(2, doc.age);
        done();
      });
    });

    it('count', function(done) {
      const m = mquery(col).count({ name: 'exec' });
      m.exec(function(err, count) {
        assert.ifError(err);
        assert.equal(2, count);
        done();
      });
    });

    it('distinct', function(done) {
      const m = mquery({ name: 'exec' });
      m.collection(col);
      m.distinct('age');
      m.exec(function(err, array) {
        assert.ifError(err);
        assert.ok(Array.isArray(array));
        assert.equal(2, array.length);
        assert(~array.indexOf(1));
        assert(~array.indexOf(2));
        done();
      });
    });

    describe('update', function() {
      describe('updateMany', function() {
        it('works', function(done) {
          mquery(col).updateMany({ name: 'exec' }, { name: 'test' }).
            exec(function(error) {
              assert.ifError(error);
              mquery(col).count({ name: 'test' }).exec(function(error, res) {
                assert.ifError(error);
                assert.equal(res, 2);
                done();
              });
            });
        });
        it('works with write concern', function(done) {
          mquery(col).updateMany({ name: 'exec' }, { name: 'test' })
            .w(1).j(true).wtimeout(1000)
            .exec(function(error) {
              assert.ifError(error);
              mquery(col).count({ name: 'test' }).exec(function(error, res) {
                assert.ifError(error);
                assert.equal(res, 2);
                done();
              });
            });
        });
      });

      describe('updateOne', function() {
        it('works', function(done) {
          mquery(col).updateOne({ name: 'exec' }, { name: 'test' }).
            exec(function(error) {
              assert.ifError(error);
              mquery(col).count({ name: 'test' }).exec(function(error, res) {
                assert.ifError(error);
                assert.equal(res, 1);
                done();
              });
            });
        });
      });

      describe('replaceOne', function() {
        it('works', function(done) {
          mquery(col).replaceOne({ name: 'exec' }, { name: 'test' }).
            exec(function(error) {
              assert.ifError(error);
              mquery(col).findOne({ name: 'test' }).exec(function(error, res) {
                assert.ifError(error);
                assert.equal(res.name, 'test');
                assert.ok(res.age == null);
                done();
              });
            });
        });
      });
    });

    describe('remove', function() {
      it('with a callback', function(done) {
        const m = mquery(col).where({ age: 2 }).remove();
        m.exec(function(err, res) {
          assert.ifError(err);
          assert.equal(1, res.deletedCount);
          done();
        });
      });

      it('without a callback', function(done) {
        const m = mquery(col).where({ age: 1 }).remove();
        m.exec();

        setTimeout(function() {
          mquery(col).where('name', 'exec').count(function(err, num) {
            assert.equal(1, num);
            done();
          });
        }, 200);
      });
    });

    describe('deleteOne', function() {
      it('with a callback', function(done) {
        const m = mquery(col).where({ age: { $gte: 0 } }).deleteOne();
        m.exec(function(err, res) {
          assert.ifError(err);
          assert.equal(res.deletedCount, 1);
          done();
        });
      });

      it('with justOne set', function(done) {
        const m = mquery(col).where({ age: { $gte: 0 } }).
          // Should ignore `justOne`
          setOptions({ justOne: false }).
          deleteOne();
        m.exec(function(err, res) {
          assert.ifError(err);
          assert.equal(res.deletedCount, 1);
          done();
        });
      });
    });

    describe('deleteMany', function() {
      it('with a callback', function(done) {
        const m = mquery(col).where({ age: { $gte: 0 } }).deleteMany();
        m.exec(function(err, res) {
          assert.ifError(err);
          assert.equal(res.deletedCount, 2);
          done();
        });
      });
    });

    describe('findOneAndUpdate', function() {
      it('with a callback', function(done) {
        const m = mquery(col);
        m.findOneAndUpdate({ name: 'exec', age: 1 }, { $set: { name: 'findOneAndUpdate' } }, { returnDocument: 'after' });
        m.exec(function(err, res) {
          assert.ifError(err);
          assert.equal('findOneAndUpdate', res.value.name);
          done();
        });
      });
    });

    describe('findOneAndRemove', function() {
      it('with a callback', function(done) {
        const m = mquery(col);
        m.findOneAndRemove({ name: 'exec', age: 2 });
        m.exec(function(err, res) {
          assert.ifError(err);
          assert.equal('exec', res.value.name);
          assert.equal(2, res.value.age);
          mquery(col).count({ name: 'exec' }, function(err, num) {
            assert.ifError(err);
            assert.equal(1, num);
            done();
          });
        });
      });
    });
  });

  describe('setTraceFunction', function() {
    beforeEach(function(done) {
      col.insertMany([{ name: 'trace', age: 93 }], done);
    });

    it('calls trace function when executing query', function(done) {
      const m = mquery(col);

      let resultTraceCalled;

      m.setTraceFunction(function(method, queryInfo) {
        try {
          assert.equal('findOne', method);
          assert.equal('trace', queryInfo.conditions.name);
        } catch (e) {
          done(e);
        }

        return function(err, result, millis) {
          try {
            assert.equal(93, result.age);
            assert.ok(typeof millis === 'number');
          } catch (e) {
            done(e);
          }
          resultTraceCalled = true;
        };
      });

      m.findOne({ name: 'trace' }, function(err, doc) {
        assert.ifError(err);
        assert.equal(resultTraceCalled, true);
        assert.equal(93, doc.age);
        done();
      });
    });

    it('inherits trace function when calling toConstructor', function(done) {
      function traceFunction() { return function() {}; }

      const tracedQuery = mquery().setTraceFunction(traceFunction).toConstructor();

      const query = tracedQuery();
      assert.equal(traceFunction, query._traceFunction);

      done();
    });
  });

  describe('thunk', function() {
    it('returns a function', function(done) {
      assert.equal('function', typeof mquery().thunk());
      done();
    });

    it('passes the fn arg to `exec`', function(done) {
      function cb() {}
      const m = mquery();

      m.exec = function testing(fn) {
        assert.equal(this, m);
        assert.equal(cb, fn);
        done();
      };

      m.thunk()(cb);
    });
  });

  describe('then', function() {
    before(function(done) {
      col.insertMany([{ name: 'then', age: 1 }, { name: 'then', age: 2 }], done);
    });

    after(function(done) {
      mquery(col).remove({ name: 'then' }).exec(done);
    });

    it('returns a promise A+ compat object', function(done) {
      const m = mquery(col).find();
      assert.equal('function', typeof m.then);
      done();
    });

    it('creates a promise that is resolved on success', function(done) {
      const promise = mquery(col).count({ name: 'then' }).then();
      promise.then(function(count) {
        assert.equal(2, count);
        done();
      }, done);
    });

    it('supports exec() cb being called synchronously #66', function(done) {
      const query = mquery(col).count({ name: 'then' });
      query.exec = function(cb) {
        cb(null, 66);
      };

      query.then(success, done);
      function success(count) {
        assert.equal(66, count);
        done();
      }
    });
  });

  describe('stream', function() {
    before(function(done) {
      col.insertMany([{ name: 'stream', age: 1 }, { name: 'stream', age: 2 }], done);
    });

    after(function(done) {
      mquery(col).remove({ name: 'stream' }).exec(done);
    });

    describe('throws', function() {
      describe('if used with non-find operations', function() {
        const ops = ['update', 'findOneAndUpdate', 'remove', 'count', 'distinct'];

        ops.forEach(function(op) {
          assert.throws(function() {
            mquery(col)[op]().stream();
          });
        });
      });
    });

    it('returns a stream', function(done) {
      const stream = mquery(col).find({ name: 'stream' }).cursor().stream();
      let count = 0;
      let err;

      stream.on('data', function(doc) {
        assert.equal('stream', doc.name);
        ++count;
      });

      stream.on('error', function(er) {
        err = er;
      });

      stream.on('end', function() {
        if (err) return done(err);
        assert.equal(2, count);
        done();
      });
    });
  });

  function noDistinct(type) {
    it('cannot be used with distinct()', function(done) {
      assert.throws(function() {
        mquery().distinct('name')[type](4);
      }, new RegExp(type + ' cannot be used with distinct'));
      done();
    });
  }

  function no(method, type) {
    it('cannot be used with ' + method + '()', function(done) {
      assert.throws(function() {
        mquery()[method]()[type](4);
      }, new RegExp(type + ' cannot be used with ' + method));
      done();
    });
  }

  // query internal

  describe('_updateForExec', function() {
    it('returns a clone of the update object with same key order #19', function(done) {
      const update = {};
      update.$push = { n: { $each: [{ x: 10 }], $slice: -1, $sort: { x: 1 } } };

      const q = mquery().updateOne({ x: 1 }, update);

      // capture original key order
      const order = [];
      let key;
      for (key in q._update.$push.n) {
        order.push(key);
      }

      // compare output
      const doc = q._updateForExec();
      let i = 0;
      for (key in doc.$push.n) {
        assert.equal(key, order[i]);
        i++;
      }

      done();
    });
  });
});
