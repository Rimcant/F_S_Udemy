With('$'));
    let valid = true;
    dollarKeys.forEach(k => {
      if (['$ref', '$id', '$db'].indexOf(k) === -1) valid = false;
    });

    // only make DBRef if $ keys are all valid
    if (valid) return DBRef.fromExtendedJSON(v);
  }

  return value;
}

type EJSONSerializeOptions = EJSON.Options & {
  seenObjects: { obj: unknown; propertyName: string }[];
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function serializeArray(array: any[], options: EJSONSerializeOptions): any[] {
  return array.map((v: unknown, index: number) => {
    options.seenObjects.push({ propertyName: `index ${index}`, obj: null });
    try {
      return serializeValue(v, options);
    } finally {
      options.seenObjects.pop();
    }
  });
}

function getISOString(date: Date) {
  const isoStr = date.toISOString();
  // we should only show milliseconds in timestamp if they're non-zero
  return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + 'Z';
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function serializeValue(value: any, options: EJSONSerializeOptions): any {
  if ((typeof value === 'object' || typeof value === 'function') && value !== null) {
    const index = options.seenObjects.findIndex(entry => entry.obj === value);
    if (index !== -1) {
      const props = options.seenObjects.map(entry => entry.propertyName);
      const leadingPart = props
        .slice(0, index)
        .map(prop => `${prop} -> `)
        .join('');
      const alreadySeen = props[index];
      const circularPart =
        ' -> ' +
        props
          .slice(index + 1, props.length - 1)
          .map(prop => `${prop} -> `)
          .join('');
      const current = props[props.length - 1];
      const leadingSpace = ' '.repeat(leadingPart.length + alreadySeen.length / 2);
      const dashes = '-'.repeat(
        circularPart.length + (alreadySeen.length + current.length) / 2 - 1
      );

      throw new BSONTypeError(
        'Converting circular structure to EJSON:\n' +
          `    ${leadingPart}${alreadySeen}${circularPart}${current}\n` +
          `    ${leadingSpace}\\${dashes}/`
      );
    }
    options.seenObjects[options.seenObjects.length - 1].obj = value;
  }

  if (Array.isArray(value)) return serializeArray(value, options);

  if (value === undefined) return null;

  if (value instanceof Date || isDate(value)) {
    const dateNum = value.getTime(),
      // is it in year range 1970-9999?
      inRange = dateNum > -1 && dateNum < 253402318800000;

    if (options.legacy) {
      return options.relaxed && inRange
        ? { $date: value.getTime() }
        : { $date: getISOString(value) };
    }
    return options.relaxed && inRange
      ? { $date: getISOString(value) }
      : { $date: { $numberLong: value.getTime().toString() } };
  }

  if (typeof value === 'number' && (!options.relaxed || !isFinite(value))) {
    // it's an integer
    if (Math.floor(value) === value) {
      const int32Range = value >= BSON_INT32_MIN && value <= BSON_INT32_MAX,
        int64Range = value >= BSON_INT64_MIN && value <= BSON_INT64_MAX;

      // interpret as being of the smallest BSON integer type that can represent the number exactly
      if (int32Range) return { $numberInt: value.toString() };
      if (int64Range) return { $numberLong: value.toString() };
    }
    return { $numberDouble: value.toString() };
  }

  if (value instanceof RegExp || isRegExp(value)) {
    let flags = value.flags;
    if (flags === undefined) {
      const match = value.toString().match(/[gimuy]*$/);
      if (match) {
        flags = match[0];
      }
    }

    const rx = new BSONRegExp(value.source, flags);
    