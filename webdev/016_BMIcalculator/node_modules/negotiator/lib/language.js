ackwards compat
  Decimal128: (o: Decimal128) => new Decimal128(o.bytes),
  Double: (o: Double) => new Double(o.value),
  Int32: (o: Int32) => new Int32(o.value),
  Long: (
    o: Long & {
      low_: number;
      high_: number;
      unsigned_: boolean | undefined;
    }
  ) =>
    Long.fromBits(
      // underscore variants for 1.x backwards compatibility
      o.low != null ? o.low : o.low_,
      o.low != null ? o.high : o.high_,
      o.low != null ? o.unsigned : o.unsigned_
    ),
  MaxKey: () => new MaxKey(),
  MinKey: () => new MinKey(),
  ObjectID: (o: ObjectId) => new ObjectId(o),
  ObjectId: (o: ObjectId) => new ObjectId(o), // support 4.0.0/4.0.1 before _bsontype was reverted back to ObjectID
  BSONRegExp: (o: BSONRegExp) => new BSONRegExp(o.pattern, o.options),
  Symbol: (o: BSONSymbol) => new BSONSymbol(o.value),
  Timestamp: (o: Timestamp) => Timestamp.fromBits(o.low, o.high)
} as const;

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function serializeDocument(doc: any, options: EJSONSerializeOptions) {
  if (doc == null || typeof doc !== 'object') throw new BSONError('not an object instance');

  const bsontype: BSONType['_bsontype'] = doc._bsontype;
  if (typeof bsontype === 'undefined') {
    // It's a regular object. Recursively serialize its property values.
    const _doc: Document = {};
    for (const name in doc) {
      options.seenObjects.push({ propertyName: name, obj: null });
      try {
        const value = serializeValue(doc[name], options);
        if (name === '__proto__') {
          Object.defineProperty(_doc, name, {
            value,
            writable: true,
            enumerable: true,
            configurable: true
          });
        } else {
          _doc[name] = value;
        }
      } finally {
        options.seenObjects.pop();
      }
    }
    return _doc;
  } else if (isBSONType(doc)) {
    // the "document" is really just a BSON type object
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let outDoc: any = doc;
    if (typeof outDoc.toExtendedJSON !== 'function') {
      // There's no EJSON serialization function on the object. It's probably an
      // object created by a previous version of this library (or another library)
      // that's duck-typing objects to look like they were generated by this library).
      // Copy the object into this library's version of that type.
      const mapper = BSON_TYPE_MAPPINGS[doc._bsontype];
      if (!mapper) {
        throw new BSONTypeError('Unrecognized or invalid _bsontype: ' + doc._bsontype);
      }
      outDoc = mapper(outDoc);
    }

    // Two BSON types may have nested objects that may need to be serialized too
    if (bsontype === 'Code' && outDoc.scope) {
      outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options));
    } else if (bsontype === 'DBRef' && outDoc.oid) {
      outDoc = new DBRef(
        serializeValue(outDoc.collection, options),
        serializeValue(outDoc.oid, options),
        serializeValue(outDoc.db, options),
        serializeValue(outDoc.fields, options)
      );
    }

    return outDoc.toExtendedJSON(options);
  } else {
    throw new BSONError('_bsontype must be a string, but was: ' + typeof bsontype);
  }
}

/**
 * EJSON parse / stringify API
 * @public
 */
// the namespace here is used to emulate `export * as EJSON from '...'`
// which as of now (sept 2020) api-extractor does not support
// eslint-disable-next-line @typescript-eslint/no-namespace
export namespace EJSON {
  export interface Options {
    /** Output using the Extend