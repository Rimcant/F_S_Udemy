declare module 'process' {
    import * as tty from 'node:tty';
    import { Worker } from 'node:worker_threads';
    global {
        var process: NodeJS.Process;
        namespace NodeJS {
            // this namespace merge is here because these are specifically used
            // as the type for process.stdin, process.stdout, and process.stderr.
            // they can't live in tty.d.ts because we need to disambiguate the imported name.
            interface ReadStream extends tty.ReadStream {}
            interface WriteStream extends tty.WriteStream {}
            interface MemoryUsageFn {
                /**
                 * The `process.memoryUsage()` method iterate over each page to gather informations about memory
                 * usage which can be slow depending on the program memory allocations.
                 */
                (): MemoryUsage;
                /**
                 * method returns an integer representing the Resident Set Size (RSS) in bytes.
                 */
                rss(): number;
            }
            interface MemoryUsage {
                rss: number;
                heapTotal: number;
                heapUsed: number;
                external: number;
                arrayBuffers: number;
            }
            interface CpuUsage {
                user: number;
                system: number;
            }
            interface ProcessRelease {
                name: string;
                sourceUrl?: string | undefined;
                headersUrl?: string | undefined;
                libUrl?: string | undefined;
                lts?: string | undefined;
            }
            interface ProcessVersions extends Dict<string> {
                http_parser: string;
                node: string;
                v8: string;
                ares: string;
                uv: string;
                zlib: string;
                modules: string;
                openssl: string;
            }
            type Platform = 'aix' | 'android' | 'darwin' | 'freebsd' | 'haiku' | 'linux' | 'openbsd' | 'sunos' | 'win32' | 'cygwin' | 'netbsd';
            type Architecture = 'arm' | 'arm64' | 'ia32' | 'mips' | 'mipsel' | 'ppc' | 'ppc64' | 's390' | 's390x' | 'x64';
            type Signals =
                | 'SIGABRT'
                | 'SIGALRM'
                | 'SIGBUS'
                | 'SIGCHLD'
                | 'SIGCONT'
                | 'SIGFPE'
                | 'SIGHUP'
                | 'SIGILL'
                | 'SIGINT'
                | 'SIGIO'
                | 'SIGIOT'
                | 'SIGKILL'
                | 'SIGPIPE'
                | 'SIGPOLL'
                | 'SIGPROF'
                | 'SIGPWR'
                | 'SIGQUIT'
                | 'SIGSEGV'
                | 'SIGSTKFLT'
                | 'SIGSTOP'
                | 'SIGSYS'
                | 'SIGTERM'
                | 'SIGTRAP'
                | 'SIGTSTP'
                | 'SIGTTIN'
                | 'SIGTTOU'
                | 'SIGUNUSED'
                | 'SIGURG'
                | 'SIGUSR1'
                | 'SIGUSR2'
                | 'SIGVTALRM'
                | 'SIGWINCH'
                | 'SIGXCPU'
                | 'SIGXFSZ'
                | 'SIGBREAK'
                | 'SIGLOST'
                | 'SIGINFO';
            type UncaughtExceptionOrigin = 'uncaughtException' | 'unhandledRejection';
            type MultipleResolveType = 'resolve' | 'reject';
            type BeforeExitListener = (code: number) => void;
            type DisconnectListener = () => void;
            type ExitListener = (code: number) => void;
            type RejectionHandledListener = (promise: Promise<unknown>) => void;
            type UncaughtExceptionListener = (error: Error, origin: UncaughtExceptionOrigin) => void;
            /**
             * Most of the time the unhandledRejection will be an Error, but this should not be relied upon
             * as *anything* can be thrown/rejected,