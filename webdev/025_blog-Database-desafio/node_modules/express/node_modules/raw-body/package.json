ta = object;
      currentLogger(msg, state);
    }
  }

  /**
   * Log a message at the error level
   *
   * @param message - The message to log
   * @param object - Additional meta data to log
   */
  error(message: string, object?: unknown): void {
    if (
      this.isError() &&
      ((Object.keys(filteredClasses).length > 0 && filteredClasses[this.className]) ||
        (Object.keys(filteredClasses).length === 0 && classFilters[this.className]))
    ) {
      const dateTime = new Date().getTime();
      const msg = format('[%s-%s:%s] %s %s', 'ERROR', this.className, pid, dateTime, message);
      const state = {
        type: LoggerLevel.ERROR,
        message,
        className: this.className,
        pid,
        date: dateTime
      } as any;

      if (object) state.meta = object;
      currentLogger(msg, state);
    }
  }

  /** Is the logger set at info level */
  isInfo(): boolean {
    return level === LoggerLevel.INFO || level === LoggerLevel.DEBUG;
  }

  /** Is the logger set at error level */
  isError(): boolean {
    return level === LoggerLevel.ERROR || level === LoggerLevel.INFO || level === LoggerLevel.DEBUG;
  }

  /** Is the logger set at error level */
  isWarn(): boolean {
    return (
      level === LoggerLevel.ERROR ||
      level === LoggerLevel.WARN ||
      level === LoggerLevel.INFO ||
      level === LoggerLevel.DEBUG
    );
  }

  /** Is the logger set at debug level */
  isDebug(): boolean {
    return level === LoggerLevel.DEBUG;
  }

  /** Resets the logger to default settings, error and no filtered classes */
  static reset(): void {
    level = LoggerLevel.ERROR;
    filteredClasses = {};
  }

  /** Get the current logger function */
  static currentLogger(): LoggerFunction {
    return currentLogger;
  }

  /**
   * Set the current logger function
   *
   * @param logger - Custom logging function
   */
  static setCurrentLogger(logger: LoggerFunction): void {
    if (typeof logger !== 'function') {
      throw new MongoInvalidArgumentError('Current logger must be a function');
    }

    currentLogger = logger;
  }

  /**
   * Filter log messages for a particular class
   *
   * @param type - The type of filter (currently only class)
   * @param values - The filters to apply
   */
  static filter(type: string, values: string[]): void {
    if (type === 'class' && Array.isArray(values)) {
      filteredClasses = {};
      values.forEach(x => (filteredClasses[x] = true));
    }
  }

  /**
   * Set the current log level
   *
   * @param newLevel - Set current log level (debug, warn, info, error)
   */
  static setLevel(newLevel: LoggerLevel): void {
    if (
      newLevel !== Lo