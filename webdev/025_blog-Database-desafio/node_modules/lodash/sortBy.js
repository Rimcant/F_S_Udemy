/**
 * The WASI API provides an implementation of the [WebAssembly System Interface](https://wasi.dev/) specification. WASI gives sandboxed WebAssembly applications access to the
 * underlying operating system via a collection of POSIX-like functions.
 *
 * ```js
 * import { readFile } from 'fs/promises';
 * import { WASI } from 'wasi';
 * import { argv, env } from 'process';
 *
 * const wasi = new WASI({
 *   args: argv,
 *   env,
 *   preopens: {
 *     '/sandbox': '/some/real/path/that/wasm/can/access'
 *   }
 * });
 *
 * // Some WASI binaries require:
 * //   const importObject = { wasi_unstable: wasi.wasiImport };
 * const importObject = { wasi_snapshot_preview1: wasi.wasiImport };
 *
 * const wasm = await WebAssembly.compile(
 *   await readFile(new URL('./demo.wasm', import.meta.url))
 * );
 * const instance = await WebAssembly.instantiate(wasm, importObject);
 *
 * wasi.start(instance);
 * ```
 *
 * To run the above example, create a new WebAssembly text format file named`demo.wat`:
 *
 * ```text
 * (module
 *     ;; Import the required fd_write WASI function which will write the given io vectors to stdout
 *     ;; The function signature for fd_write is:
 *     ;; (File Descriptor, *iovs, iovs_len, nwritten) -> Returns number of bytes written
 *     (import "wasi_snapshot_preview1" "fd_write" (func $fd_write (param i32 i32 i32 i32) (result i32)))
 *
 *     (memory 1)
 *     (export "memory" (memory 0))
 *
 *     ;; Write 'hello world\n' to memory at an offset of 8 bytes
 *     ;; Note the trailing newline which is required for the text to appear
 *     (data (i32.const 8) "hello world\n")
 *
 *     (func $main (export "_start")
 *         ;; Creating a new io vector within linea