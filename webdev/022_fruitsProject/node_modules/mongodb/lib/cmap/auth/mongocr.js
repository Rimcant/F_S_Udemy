import {
  BLOCK_SIZE,
  DIGEST_LENGTH,
  INIT,
  KEY,
  MAX_HASHABLE_LENGTH
} from "./constants";

/**
 * @internal
 */
export class RawSha256 {
  private state: Int32Array = Int32Array.from(INIT);
  private temp: Int32Array = new Int32Array(64);
  private buffer: Uint8Array = new Uint8Array(64);
  private bufferLength: number = 0;
  private bytesHashed: number = 0;

  /**
   * @internal
   */
  finished: boolean = false;

  update(data: Uint8Array): void {
    if (this.finished) {
      throw new Error("Attempted to update an already finished hash.");
    }

    let position = 0;
    let { byteLength } = data;
    this.bytesHashed += byteLength;

    if (this.bytesHashed * 8 > MAX_HASHABLE_LENGTH) {
      throw new Error("Cannot hash more than 2^53 - 1 bits");
    }

    while (byteLength > 0) {
      this.buffer[this.bufferLength++] = data[position++];
      byteLength--;

      if (this.bufferLength === BLOCK_SIZE) {
        this.hashBuffer();
        this.bufferLength = 0;
      }
    }
  }

  digest(): Uint8Array {
    if (!this.finished) {
      const bitsHashed = this.bytesHashed * 8;
      const bufferView = new DataView(
        this.buffer.buffer,
        this.buffer.byteOffset,
        this.buffer.byteLength
      );

      const undecoratedLength = this.bufferLength;
      bufferView.setUint8(this.bufferLength++, 0x80);

      // Ensure the final block has enough room for the hashed length
      if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {
        for (let i = this.bufferLength; i < BLOCK_SIZE; i++) {
          bufferView.setUint8(i, 0);
        }
        this.hashBuffer();
        this.bufferLength = 0;
      }

      for (let i = this.bufferLength; i < BLOCK_SIZE - 8; i++) {
        bufferView.setUint8(i, 0);
      }
      bufferView.setUint32(
        BLOCK_SIZE - 8,
    