import { Key, Comparator } from "./utils";
export interface Operation<TItem> {
    readonly keep: boolean;
    readonly done: boolean;
    propop: boolean;
    reset(): any;
    next(item: TItem, key?: Key, owner?: any, root?: boolean): any;
}
export declare type Tester = (item: any, key?: Key, owner?: any, root?: boolean) => boolean;
export interface NamedOperation {
    name: string;
}
export declare type OperationCreator<TItem> = (params: any, parentQuery: any, options: Options, name: string) => Operation<TItem>;
export declare type BasicValueQuery<TValue> = {
    $eq?: TValue;
    $ne?: TValue;
    $lt?: TValue;
    $gt?: TValue;
    $lte?: TValue;
    $gte?: TValue;
    $in?: TValue[];
    $nin?: TValue[];
    $all?: TValue[];
    $mod?: [number, number];
    $exists?: boolean;
    $regex?: string | RegExp;
    $size?: number;
    $where?: ((this: TValue, obj: TValue) => boolean) | string;
    $options?: "i" | "g" | "m" | "u";
    $type?: Function;
    $not?: NestedQuery<TValue>;
    $or?: NestedQuery<TValue>[];
    $nor?: NestedQuery<TValue>[];
    $and?: NestedQuery<TValue>[];
};
export declare type ArrayValueQuery<TValue> = {
    $elemMatch?: Query<TValue>;
} & BasicValueQuery<TValue>;
declare type Unpacked<T> = T extends (infer U)[] ? U : T;
export declare type ValueQuery<TValue> = TValue extends Array<any> ? ArrayValueQuery<Unpacked<TValue>> : BasicValueQuery<TValue>;
declare type NotObject = string | number | Date | boolean | Array<any>;
export declare type ShapeQuery<TItemSchema> = TItemSchema extends NotObject ? {} : {
    [k in keyof TItemSchema]?: TItemSchema[k] | ValueQuery<TItemSchema[k]>;
};
export declare type NestedQuery<TItemSchema> = ValueQuery<TItemSchema> & ShapeQuery<TItemSchema>;
export declare type Query<TItemSchema> = TItemSchema | RegExp | NestedQuery<TItemSchema>;
export declare type QueryOperators<TValue = any> = keyof ValueQuery<TValue>;
export declare abstract class BaseOperation<TParams, TItem = any> implements Operation<TItem> {
    readonly params: TParams;
    readonly owneryQuery: any;
    readonly options: Options;
    readonly name?: string;
    keep: boolean;
    done: boolean;
    abstract propop: boolean;
    constructor(params: TParams, owneryQuery: any, options: Options, name?: string);
    protected init(): void;
    reset(): void;
    abstract next(item: any, key: Key, parent: any, root: boolean): any;
}
declare abstract class GroupOperation extends BaseOperation<any> {
    readonly children: Operation<any>[];
    keep: boolean;
    done: boolean;
    constructor(params: any, owneryQuery: any, options: Options, children: Operation<any>[]);
    /**
     */
    reset(): void;
    abstract next(item: any, key: Key, owner: any, root: boolean): any;
    /**
     */
    protected childrenNext(item: any, key: Key, owner: any, root: boolean): void;
}
export declare abstract class NamedGroupOperation extends GroupOperation implements NamedOperation {
    readonly name: string;
    abstract propop: boolean;
    constructor(param