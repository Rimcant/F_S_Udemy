: 'this was changed too', y: 3 }] }}
    , { o: { array: [3, 0, null] }}
    , { o: { name: 'ha' }}
  ];
}
```

####Setting arrays

By default, setting a property within an array to another array results in each element of the new array being set to the item in the destination array at the matching index. An example is helpful.

```js
var obj = {
    comments: [
      { title: 'funny' },
      { title: 'exciting!' }
    ]
}

mpath.set('comments.title', ['hilarious', 'fruity'], obj);

console.log(obj); // prints..

  { comments: [
      { title: 'hilarious' },
      { title: 'fruity' }
  ]}
```

If we do not desire this destructuring-like assignment behavior we may instead specify the `$` operator in the path being set to force the array to be copied directly.

```js
var obj = {
    comments: [
      { title: 'funny' },
      { title: 'exciting!' }
    ]
}

mpath.set('comments.$.title', ['hilarious', 'fruity'], obj);

console.log(obj); // prints..

  { comments: [
      { title: ['hilarious', 'fruity'] },
      { title: ['hilarious', 'fruity'] }
  ]}
```

####Field assignment rules

The rules utilized mirror those used on `mpath.get`, meaning we can take values returned from `mpath.get`, update them, and reassign them using `mpath.set`. Note that setting nested arrays of arrays can get unweildy quickly. Check out the [tests](https://github.com/aheckmann/mpath/blob/master/test/index.js) for more extreme examples.

#####Maps

`mpath.set` also accepts an optional `map` argument which receives each individual value being set. The value returned from the `map` function will be used in the original values place.

```js
var obj = {
    comments: [
      { title: 'funny' },
      { title: 'exciting!' }
    ]
}

mpath.set('comments.title', ['hilarious', 'fruity'], obj, function (val) {
  return val.length;
});

console.log(obj); /