"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMongoDBClientEncryption = exports.commandSupportsReadConcern = exports.shuffle = exports.parsePackageVersion = exports.supportsRetryableWrites = exports.enumToString = exports.emitWarningOnce = exports.emitWarning = exports.MONGODB_WARNING_CODE = exports.DEFAULT_PK_FACTORY = exports.HostAddress = exports.BufferPool = exports.List = exports.deepCopy = exports.isRecord = exports.setDifference = exports.isHello = exports.isSuperset = exports.resolveOptions = exports.hasAtomicOperators = exports.calculateDurationInMs = exports.now = exports.makeClientMetadata = exports.makeStateMachine = exports.errorStrictEqual = exports.arrayStrictEqual = exports.eachAsyncSeries = exports.eachAsync = exports.maxWireVersion = exports.uuidV4 = exports.databaseNamespace = exports.maybeCallback = exports.makeCounter = exports.MongoDBNamespace = exports.ns = exports.deprecateOptions = exports.defaultMsgHandler = exports.getTopology = exports.decorateWithExplain = exports.decorateWithReadConcern = exports.decorateWithCollation = exports.isPromiseLike = exports.applyWriteConcern = exports.applyRetryableWrites = exports.filterOptions = exports.mergeOptions = exports.isObject = exports.normalizeHintField = exports.checkCollectionName = exports.MAX_JS_INT = void 0;
exports.compareObjectId = void 0;
const crypto = require("crypto");
const os = require("os");
const url_1 = require("url");
const bson_1 = require("./bson");
const constants_1 = require("./cmap/wire_protocol/constants");
const constants_2 = require("./constants");
const error_1 = require("./error");
const promise_provider_1 = require("./promise_provider");
const read_concern_1 = require("./read_concern");
const read_preference_1 = require("./read_preference");
const common_1 = require("./sdam/common");
const write_concern_1 = require("./write_concern");
exports.MAX_JS_INT = Number.MAX_SAFE_INTEGER + 1;
/**
 * Throws if collectionName is not a valid mongodb collection namespace.
 * @internal
 */
function checkCollectionName(collectionName) {
    if ('string' !== typeof collectionName) {
        throw new error_1.MongoInvalidArgumentError('Collection name must be a String');
    }
    if (!collectionName || collectionName.indexOf('..') !== -1) {
        throw new error_1.MongoInvalidArgumentError('Collection names cannot be empty');
    }
    if (collectionName.indexOf('$') !== -1 &&
        collectionName.match(/((^\$cmd)|(oplog\.\$main))/) == null) {
        // TODO(NODE-3483): Use MongoNamespace static method
        throw new error_1.MongoInvalidArgumentError("Collection names must not contain '$'");
    }
    if (collectionName.match(/^\.|\.$/) != null) {
        // TODO(NODE-3483): Use MongoNamespace static method
        throw new error_1.MongoInvalidArgumentError("Collection names must not start or end with '.'");
    }
    // Validate that we are not passing 0x00 in the collection name
    if (collectionName.indexOf('\x00') !== -1) {
        // TODO(NODE-3483): Use MongoNamespace static method
        throw new error_1.MongoInvalidArgumentError('Collection names cannot contain a null character');
    }
}
exports.checkCollectionName = checkCollectionName;
/**
 * Ensure Hint field is in a shape we expect:
 * - object of index names mapping to 1 or -1
 * - just an index name
 * @internal
 */
function normalizeHintField(hint) {
    let finalHint = undefined;
    if (typeof hint === 'string') {
        finalHint = hint;
    }
    else if (Array.isArray(hint)) {
        finalHint = {};
        hint.forEach(param => {
            finalHint[param] = 1;
        });
    }
    else if (hint != null && typeof hint === 'object') {
        finalHint = {};
        for (const name in hint) {
            finalHint[name] = hint[name];
        }
    }
    return finalHint;
}
exports.normalizeHintField = normalizeHintField;
const TO_STRING = (object) => Object.prototype.toString.call(object);
/**
 * Checks if arg is an Object:
 * - **NOTE**: the check is based on the `[Symbol.toStringTag]() === 'Object'`
 * @internal
 */
function isObject(arg) {
    return '[object Object]' === TO_STRING(arg);
}
exports.isObject = isObject;
/** @internal */
function mergeOptions(target, source) {
    return { ...target, ...source };
}
exports.mergeOptions = mergeOptions;
/** @internal */
function filterOptions(options, names) {
    const filterOptions = {};
    for (const name in options) {
        if (names.includes(name)) {
            filterOptions[name] = options[name];
        }
    }
    // Filtered options
    return filterOptions;
}
exports.filterOptions = filterOptions;
/**
 * Applies retryWrites: true to a command if retryWrites is set on the command's database.
 * @internal
 *
 * @param target - The target command to which we will apply retryWrites.
 * @param db - The database from which we can inherit a retryWrites value.
 */
function applyRetryableWrites(target, db) {
    var _a;
    if (db && ((_a = db.s.options) === null || _a === void 0 ? void 0 : _a.retryWrites)) {
        target.retryWrites = true;
    }
    return target;
}
exports.applyRetryableWrites = applyRetryableWrites;
/**
 * Applies a write concern to a command based on well defined inheritance rules, optionally
 * detecting support for the write concern in the first place.
 * @internal
 *
 * @param target - the target command we will be applying the write concern to
 * @param sources - sources where we can inherit default write concerns from
 * @param options - optional settings passed into a command for write concern overrides
 */
function applyWriteConcern(target, sources, options) {
    options = options !== null && options !== void 0 ? options : {};
    const db = sources.db;
    const coll = sources.collection;
    if (options.session && options.session.inTransaction()) {
        // writeConcern is not allowed within a multi-statement transaction
        if (target.writeConcern) {
            delete target.writeConcern;
        }
        return target;
    }
    const writeConcern = write_concern_1.WriteConcern.fromOptions(options);
    if (writeConcern) {
        return Object.assign(target, { writeConcern });
    }
    if (coll && coll.writeConcern) {
        return Object.assign(target, { writeConcern: Object.assign({}, coll.writeConcern) });
    }
    if (db && db.writeConcern) {
        return Object.assign(target, { writeConcern: Object.assign({}, db.writeConcern) });
    }
    return target;
}
exports.applyWriteConcern = applyWriteConcern;
/**
 * Checks if a given value is a Promise
 *
 * @typeParam T - The resolution type of the possible promise
 * @param value - An object that could be a promise
 * @returns true if the provided value is a Promise
 */
function isPromiseLike(value) {
    return !!value && typeof value.then === 'function';
}
exports.isPromiseLike = isPromiseLike;
/**
 * Applies collation to a given command.
 * @internal
 *
 * @param command - the command on which to apply collation
 * @param target - target of command
 * @param options - options containing collation settings
 */
function decorateWithCollation(command, target, options) {
    const capabilities = getTopology(target).capabilities;
    if (options.collation && typeof options.collation === 'object') {
        if (capabilities && capabilities.commandsTakeCollation) {
            command.collation = options.collation;
        }
        else {
            throw new error_1.MongoCompatibilityError(`Current topology does not support collation`);
        }
    }
}
exports.decorateWithCollation = decorateWithCollation;
/**
 * Applies a read concern to a given command.
 * @internal
 *
 * @param command - the command on which to apply the read concern
 * @param coll - the parent collection of the operation calling this method
 */
function decorateWithReadConcern(command, coll, options) {
    if (options && options.session && options.session.inTransaction()) {
        return;
    }
    const readConcern = Object.assign({}, command.readConcern || {});
    if (coll.s.readConcern) {
        Object.assign(readConcern, coll.s.readConcern);
    }
    if (Object.keys(readConcern).length > 0) {
        Object.assign(command, { readConcern: readConcern });
    }
}
exports.decorateWithReadConcern = decorateWithReadConcern;
/**
 * Applies an explain to a given command.
 * @internal
 *
 * @param command - the command on which to apply the explain
 * @param options - the options containing the explain verbosity
 */
function decorateWithExplain(command, explain) {
    if (command.explain) {
        return command;
    }
    return { explain: command, verbosity: explain.verbosity };
}
exports.decorateWithExplain = decorateWithExplain;
/**
 * A helper function to get the topology from a given provider. Throws
 * if the topology cannot be found.
 * @throws MongoNotConnectedError
 * @internal
 */
function getTopology(provider) {
    // MongoClient or ClientSession or AbstractCursor
    if ('topology' in provider && provider.topology) {
        return provider.topology;
    }
    else if ('s' in provider && 'client' in provider.s && provider.s.client.topology) {
        return provider.s.client.topology;
    }
    else if ('s' in provider && 'db' in provider.s && provider.s.db.s.client.topology) {
        return provider.s.db.s.client.topology;
    }
    throw new error_1.MongoNotConnectedError('MongoClient must be connected to perform this operation');
}
exports.getTopology = getTopology;
/**
 * Default message handler for generating deprecation warnings.
 * @internal
 *
 * @param name - function name
 * @param option - option name
 * @returns warning message
 */
function defaultMsgHandler(name, option) {
    return `${name} option [${option}] is deprecated and will be removed in a later version.`;
}
exports.defaultMsgHandler = defaultMsgHandler;
/**
 * Deprecates a given function's options.
 * @internal
 *
 * @param this - the bound class if this is a method
 * @param config - configuration for deprecation
 * @param fn - the target function of deprecation
 * @returns modified function that warns once per deprecated option, and executes original function
 */
function deprecateOptions(config, fn) {
    if (process.noDeprecation === true) {
        return fn;
    }
    const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;
    const optionsWarned = new Set();
    function deprecated(...args) {
        const options = args[config.optionsIndex];
        // ensure options is a valid, non-empty object, otherwise short-circuit
        if (!isObject(options) || Object.keys(options).length === 0) {
            return fn.bind(this)(...args); // call the function, no change
        }
        // interrupt the function call with a warning
        for (const deprecatedOption of config.deprecatedOptions) {
            if (deprecatedOption in options && !optionsWarned.has(deprecatedOption)) {
                optionsWarned.add(deprecatedOption);
                const msg = msgHandler(config.name, deprecatedOption);
                emitWarning(msg);
                if (this && 'getLogger' in this) {
                    const logger = this.getLogger();
                    if (logger) {
                        logger.warn(msg);
                    }
                }
            }
        }
        return fn.bind(this)(...args);
    }
    // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80
    // The wrapper will keep the same prototype as fn to maintain prototype chain
    Object.setPrototypeOf(deprecated, fn);
    if (fn.prototype) {
        // Setting this (rather than using Object.setPrototype, as above) ensures
        // that calling the unwrapped constructor gives an instanceof the wrapped
        // constructor.
        deprecated.prototype = fn.prototype;
    }
    return deprecated;
}
exports.deprecateOptions = deprecateOptions;
/** @internal */
function ns(ns) {
    return MongoDBNamespace.fromString(ns);
}
exports.ns = ns;
/** @public */
class MongoDBNamespace {
    /**
     * Create a namespace object
     *
     * @param db - database name
     * @param collection - collection name
     */
    constructor(db, collection) {
        this.db = db;
        this.collection = collection === '' ? undefined : collection;
    }
    toString() {
        return this.collection ? `${this.db}.${this.collection}` : this.db;
    }
    withCollection(collection) {
        return new MongoDBNamespace(this.db, collection);
    }
    static fromString(namespace) {
        if (typeof namespace !== 'string' || namespace === '') {
            // TODO(NODE-3483): Replace with MongoNamespaceError
            throw new error_1.MongoRuntimeError(`Cannot parse namespace from "${namespace}"`);
        }
        const [db, ...collectionParts] = namespace.split('.');
        const collection = collectionParts.join('.');
        return new MongoDBNamespace(db, collection === '' ? undefined : collection);
    }
}
exports.MongoDBNamespace = MongoDBNamespace;
/** @internal */
function* makeCounter(seed = 0) {
    let count = seed;
    while (true) {
        const newCount = count;
        count += 1;
        yield newCount;
    }
}
exports.makeCounter = makeCounter;
function maybeCallback(promiseFn, callback) {
    const PromiseConstructor = promise_provider_1.PromiseProvider.get();
    const promise = promiseFn();
    if (callback == null) {
        if (PromiseConstructor == null) {
            return promise;
        }
        else {
            return new PromiseConstructor((resolve, reject) => {
                promise.then(resolve, reject);
            });
        }
    }
    promise.then(result => callback(undefined, result), error => callback(error));
    return;
}
exports.maybeCallback = maybeCallback;
/** @internal */
function databaseNamespace(ns) {
    return ns.split('.')[0];
}
exports.databaseNamespace = databaseNamespace;
/**
 * Synchronously Generate a UUIDv4
 * @internal
 */
function uuidV4() {
    const result = crypto.randomBytes(16);
    result[6] = (result[6] & 0x0f) | 0x40;
    result[8] = (result[8] & 0x3f) | 0x80;
    return result;
}
exports.uuidV4 = uuidV4;
/**
 * A helper function for determining `maxWireVersion` between legacy and new topology instances
 * @internal
 */
function maxWireVersion(topologyOrServer) {
    if (topologyOrServer) {
        if (topologyOrServer.loadBalanced) {
            // Since we do not have a monitor, we assume the load balanced server is always
            // pointed at the latest mongodb version. There is a risk that for on-prem
            // deployments that don't upgrade immediately that this could alert to the
            // application that a feature is available that is actually not.
            return constants_1.MAX_SUPPORTED_WIRE_VERSION;
        }
        if (topologyOrServer.hello) {
            return topologyOrServer.hello.maxWireVersion;
        }
        if ('lastHello' in topologyOrServer && typeof topologyOrServer.lastHello === 'function') {
            const lastHello = topologyOrServer.lastHello();
            if (lastHello) {
                return lastHello.maxWireVersion;
            }
        }
        if (topologyOrServer.description &&
            'maxWireVersion' in topologyOrServer.description &&
            topologyOrServer.description.maxWireVersion != null) {
            return topologyOrServer.description.maxWireVersion;
        }
    }
    return 0;
}
exports.maxWireVersion = maxWireVersion;
/**
 * Applies the function `eachFn` to each item in `arr`, in parallel.
 * @internal
 *
 * @param arr - An array of items to asynchronously iterate over
 * @param eachFn - A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.
 * @param callback - The callback called after every item has been iterated
 */
function eachAsync(arr, eachFn, callback) {
    arr = arr || [];
    let idx = 0;
    let awaiting = 0;
    for (idx = 0; idx < arr.length; ++idx) {
        awaiting++;
        eachFn(arr[idx], eachCallback);
    }
    if (awaiting === 0) {
        callback();
        return;
    }
    function eachCallback(err) {
        awaiting--;
        if (err) {
            callback(err);
            return;
        }
  ÿ²oŽÿ²nŽþ³nŽþ±mŒú½t–ÿ±nŽÏµs”dÊ«|Èˆ¥ØÓ®ÿÅ…£ûÄ„¢ÿÄ„¢ÿÄƒ¡ÿÄ„¡ÿÀ|›ÿÅ†£ÿæËØÿûøúÿÿÿÿÿüùúÿçÏÙÿÁ„¡ÿºv–ÿ½}›ÿ¼z™ÿ»y˜ÿ»z˜ÿ¸t”ÿÀ†¡ÿàÃÐÿþýþÿþþþÿÿÿÿÿãËÖÿ¿… ÿ³oÿ³pÿµq‘ÿ´pÿ³oÿ³oþ³oþ²nú¾u—ÿ³oŽÏ¸u‘dÊŽ«|Èˆ¥ØÓŽ®ÿÅ„£ûÄ„¡ÿÄ„¢ÿÃƒ¡ÿÄ„¡ÿÀ|›ÿÄ†£ÿæËØÿûøúÿÿÿÿÿüùúÿçÏÚÿÁ„¡ÿºv–ÿ½}šÿ¼z™ÿ»y˜ÿ»z˜ÿ»z—ÿ·s’ÿËš±ÿòæìÿþýþÿÿÿÿÿöïóÿ×±Âÿ¶r’ÿ´qÿµq‘ÿ´pÿ³oÿ³nþ³oþ±nú¾u—ÿ±oŽÏ¸u‘dÍ‘¬{Èˆ¦×Ô¯ÿÇ†¤úÆ…£þÆ†£þÄ„¢ÿÄ…£ÿÁ}œÿÅ‡¤ÿæÊ×ÿúöøÿþýýÿû÷øÿæÍÙÿÂ…¢ÿ»w—ÿ¾}›ÿ½{™ÿ¼z˜ÿ¼z˜ÿ½|™ÿ·q‘ÿ¾ÿÞÀÎÿûùúÿýüýÿýüüÿèÕÝÿ¿ƒŸÿµq‘ÿµqÿ´r‘ÿ³pÿ´oþ´oþ²nŽú¿u˜ÿ³oÎ·v•cÎ’­|ÊŠ§×Ô°ÿÇ†¥ûÆ…£ÿÆ†£ÿÅ…£ÿÅ†¤ÿÁ~ÿÆˆ¥ÿèÏÚÿüüýÿÿÿÿÿþýþÿèÒÜÿÃ†£ÿ¼x˜ÿ¿~œÿ¾|šÿ½{™ÿ½{™ÿ¼{šÿºw—ÿºx–ÿÎŸ´ÿùóöÿÿÿÿÿÿÿÿÿöðòÿÏ£¸ÿ¶s“ÿ´oÿµt’ÿ´qÿµp‘þµp‘þ´oúÀv™ÿµq‘Î¸x–dÍ‘¬{Ê‹¨×Ö’²þÈˆ¦úÇ‡¥þÈ‡¥þÇ†¤þÆ…£ÿÂžÿÆˆ¥ÿãÆÔÿöîòÿúõ÷ÿ÷îóÿäÉÖÿÃ†¢ÿ½y™ÿÀÿ¾}›ÿ½|šÿ¾|šÿ½{™ÿ¼{™ÿºu”ÿÃŠ¥ÿê×àÿøóõÿùôöÿòèíÿÖ°Âÿ¸w•ÿ´oÿ·u“ÿ¶r’þµq‘þµr’ýµqùÂwšþµr‘Î¹y•cÉŽ©hÊ‹©Ð×’³ÿÉˆ§ùÉˆ¦ýÉˆ¦ýÇ†¤ÿÈ†¤þÅƒ¡þÆ‡¤þÔ¦»þß»ÌþáÀÏþÞºËþÔ¥¼þÃƒ¡þÀ|œþÁ~žþÀ~þ¿}œþ¿}œþ¿|›þ¾{šþ¼w—þ¾þÐ¤¹þÙ·ÇþÜ»ËþØ²ÅþËš±þ¹w—þ·r“þ¸t•þ¶s’ÿ¶s’ý´r‘ýµqúÁxšÿµr‘Å·{”QÑ¬7Ë‹©µÕ’±þÉ‰¦ùÉˆ¦ýÉˆ¦ýÆ†¤ÿÈ†¤þÆ…£þÅ…£þÆ†¤þÆ†¤þÅ…£þÄ„¢þÂ„ þÂ þÁžþÁ~þÀ}þ¿|œþ¿}œþ¾|›þ¾{šþ½z™þ¼z™þ¼{šþ¼{šþ¼zšþ»y˜þºy—þ¹w–þ¸u•þ¸t”þ¶s’ÿ¶s’ýµr‘ýµq‘ú¼v–ÿ¶s“§ºu˜%ßŸŸÎ‘«mÍŽ«ìÓ®ÿÉ‰¦úÊ‰§ùÉˆ¦ùÇ‡¤úÆ†¤úÆ…¢úÅƒ¡úÃŸúÂ~žúÁ}úÁ~úÃ‚ŸúÂŸúÁžúÀ~žúÀ}úÀ}ú¿}œú¾|›ú½{šú½z˜ú»w—ú¹t•ú¹s”ú¸r“ú¸t“úºv•ú¹v•ú¸u•ú·u”ù·s“ú¶s’û¾w˜ÿ¸u”â¸w•^¿€€    Ó•°Ë¨‰ÎŽ­âÑ®ÿØ”³ÿ×’²ÿÖ‘±ÿÕ°ÿÔ¯ÿÕ°ÿÕ‘°ÿÓ°ÿÒ®ÿÒ­ÿÒŒ¬ÿÑ‹«ÿÐ‰ªÿÎˆ©ÿÎ‡¨ÿÎˆ©ÿÍ‡¨ÿÌ†¦ÿË†¥ÿË…¥ÿÌ†¦ÿË†¦ÿÊ„¥ÿÉƒ¤ÿÈ¢ÿÈ€¡ÿÇ€ ÿÆŸÿÅ~ŸÿÅ}žÿ¼x˜ÿºv–Û¶v“{¹—    €      Õ•ªÊŽ«aÌŒ«¤ÊŒªÅÊ‰¨ÐÉˆ§ÐÈ‡¦ÐÆ…£ÑÇ…£ÑÆ…¢ÑÆ„¢ÑÄƒ¡ÑÂƒ ÑÄƒ¡ÑÃ ÑÂ€ŸÑÁÑÀ~œÑÁ€ÑÀ~œÑ¾~œÑ¾~›Ñ½|šÑ½|šÑ¼{šÑ¼z™Ñ»y—Ñ¹y–Ñ»y–Ñºw–Ð¹w–Ð¹w•Ï¹x–Â¸w•Ÿ¹x•W¸€œ           ÿ          ×—¯ Î“±NÍŒªfÌ‰§hÉˆ¦gÇ„¤hÇ‡¤hÄ„¤hÇ„¢hÄ‚ŸhÂŸhÄŸhÂh¿‚ŸhÂhÂ}šhÂšh¿}šh½Ÿh¿{h¿xšh½xhºxšh¿}šh½{˜h¼y—g¿|—g·w—gºx˜h½}™d¾|›J¶€›                                                                                                                                                                                                                                                                                                                                               (   0   `                                  ÿ  ÿ ÿ    ÿÿ »ˆ™¶x•F¶u’^³nŒd³nŒd²l‹c«i‡d«k‡d°iŠd°f‡d°f‡d­i…d«iŠd«iŠd­f‡d«c…d«f‡d«c…d¨a‚d¨c‚d¦a…d¨^‚d¨^‚d¦a€d£^‚d£^‚d¦\€d¦a}d¦a}d£^€d¤^€b¤`€b¢]|c£\}d¢]~c¥b[­f…Aªu•        ÿ ÿ       ÿ ÿ        ¹{•¸t‘O¶s’~´r’³q¬²o¯±n°°mŒ¯¯kŠ°¯mŠ°¯k‹°®jŠ°¯jŠ°®jˆ°¬jˆ°¬jˆ°¬h‡°«g…°«h‡°«e…°ªd„°ªe„°¨d„°¨c‚°¨c‚°¨c°§a°§a‚°§`°¥`°¥a°¥`°¥_¯¥_¯£]}¯¢]}°¢]}¯¤]€ª¦^š¤`€x¢aG¦d…               ªUª¾v'¸v•}¸v”Ìµqû»t—ÿ¼u•ÿ»u•ÿ»u•ÿºt”ÿºs“ÿºs“ÿ¹r“ÿ¸q’ÿ¸q’ÿ¸p‘ÿ·oÿ·oÿ¶nÿµmŽÿµnÿµmŽÿ´lÿ´lÿ³kŒÿ²j‹ÿ²j‹ÿ²iŠÿ±hˆÿ±hŠÿ°g‰ÿ¯fˆÿ¯gˆÿ¯f‡ÿ®e…ÿ®d†ÿ­c…ÿ«b„ÿªb„ÿ«`„ÿ©_‚ÿ¢]~÷¤_Â¤]‚p¥c{ÿ         ºu˜%ºx–ˆ¶t“á¹u–ü¶q‘ÿ¸s“ÿ·r’ÿ¶q‘ÿ¶r’ÿµqÿµpÿ¶qÿµpÿ³nŽÿ³nÿ²mŽÿ±lŒÿ²lŒÿ±k‹ÿ°jŠÿ°j‹ÿ¯jŠÿ®i‰ÿ¯i‰ÿ®hˆÿ­g‡ÿ­g‡ÿ¬f†ÿ«e…ÿ­f†ÿ¬f‡ÿ«e†ÿ«e†ÿªe…ÿ©cƒÿ©b‚ÿ¨`ÿ§`€ÿ§`€ÿ¦^ÿ¥]ÿ¢\}ÿ§^ú¢\~Ù£^~wªh{    »ˆ™ºw˜\·u”Ü¼w—ÿ»v–ÿµrû¶r‘úµqû´oû´pû³oŽû±nû²lŒû±lŒû±nŒû±mŒû°l‹û¯jŠû¯kŠû¯j‰û®iˆû®hˆû­hˆû¬g‡û¬h‡û¬g†û«e…û«f…ûªe…û¨cƒû§^û¥Z}û£X{û£X{û¢Y{û£[}û¦_€û¦_€û¥^~û¥^~û¤]~û£]}ú¢[}û¨_ÿ¥]ÿ¢]~Í£_|N¶mmÀ‚Ÿ5¸w—ºv—ÿºv•ü·r’úµs‘ý¶s’ý´qÿ´pþµo‘þ´oþ³nþ³mŽþ±kŒþ°k‹þ±lŒþ±lŒþ°kŒþ°kŒþ¯j‹þ®iŠþ¯iŠþ®h‰þ­gˆþ­hˆþ¬gˆþ¬f‡þ¬f‡þ«d…þªd…þ¬g‡þ¬hˆþ¬hˆþ¬iˆþ«g†þ¨d…þ¦`‚þ¦_þ¦_þ¦_þ¤^ÿ¤^~ý¢]}ý¡\}û¥]~ü¢]}ú¢]­i‡"¼~™_»w–­Â{œÿ¼v–ÿ¸t“ú¶s’ý¶s’ý´qÿ´p‘þµp‘þ´nþ¶s’þ¼~œþ·w•þ±kŒþ±lþ²mŽþ°lþ°kþ¯j‹þ¯iŠþ¯iŠþ®h‰þ­gˆþ­gˆþ¬gˆþ¬gˆþ¬gˆþªaƒþ®kŠþ¿‹£þÊ ´þÎ§ºþÏ¨ºþÉž²þ»†Ÿþ©f…þ¤[}þ¦`þ¦_þ¤^ÿ¤^~ý¤^~ý£\~û¥^ÿ©`ƒÿ¤_€Ÿ¬lˆG»~›u»y˜¸Ã|ü¼w˜þ¹u”ú·s“þ·s“þ¶r’þ´qÿµr‘ÿ°j‹ÿ¸z—ÿÎ¤¸ÿÐ§ºÿ¾† ÿ°k‹ÿ®f‡ÿ±nŒÿ°l‹ÿ¯k‹ÿ®jŠÿ¯jŠÿ®i‰ÿ­hˆÿ­hˆÿ¬hˆÿ¬hˆÿ¬hˆÿ§^€ÿ±qÿÓ¯¿ÿéÙáÿðåêÿðåêÿèÕßÿÏ¨ºÿ­l‰ÿ¢X{ÿ¦b‚ÿ¦`€ÿ¦_þ¥^~þ¥_ý¤^~ú§^þ«a„ý¥`€ª©i…\½Ÿwºz˜ºÂ{žþºx—ÿ¸v”û·t“ÿ·t“ÿ¶s’ÿµs‘ÿ¶t’ÿ®gˆÿ»~šÿÞÀÍÿíÝäÿÛ½Ëÿ¿ˆ¡ÿ°k‹ÿ¯kŠÿ¯kŠÿ°lŒÿ¯k‹ÿ¯k‹ÿ¯jŠÿ®i‰ÿ®i‰ÿ­hˆÿ¬h‡ÿ­iˆÿ¥\~ÿ³t’ÿÝÂÎÿúõ÷ÿÿÿÿÿÿÿÿÿ÷ñôÿÙºÈÿ¯oŒÿ¡W{ÿ¨cƒÿ¦aÿ¦`€ÿ¦_þ¦_þ¥^~û§_€ÿ¬b„þ¥`¬«gˆ^½€x»{™»Ã|žþ»x—ÿ¸v”û¶t“ÿ·t“ÿ¶s’ÿµs’ÿ¶t’ÿ°h‰ÿ»|™ÿÝ¾ÍÿùôöÿøôõÿàÆÒÿÁ¤ÿ°m‹ÿ®jŠÿ±mŒÿ°l‹ÿ¯k‹ÿ®jŠÿ­i‰ÿ®i‰ÿ­hˆÿ¬h‡ÿ­iˆÿ¦]ÿ³u“ÿÜÁÎÿùôõÿÿÿÿÿÿÿÿÿ÷ñòÿØºÈÿ¯pÿ¡X{ÿ¨cƒÿ¦`ÿ¥`€ÿ¥_þ¦_þ¥^~û§_€ÿ­b…þ§`‚­¬i‰_¿~œw¼z˜ºÃ}žÿ¼y˜ÿ¹w•û¸u•þ¹u•þ·t“ÿ·t“ÿ·u“ÿ±iŠÿ»|™ÿÜ½Ëÿùôöÿÿÿÿÿ÷òôÿãËÖÿÊ²ÿµv”ÿ¯jŠÿ±mÿ°kŒÿ¯k‹ÿ®jŠÿ¯jŠÿ®i‰ÿ®iˆÿ®jŠÿ§^€ÿ´u’ÿÛ¾Ìÿöðóÿþýýÿþýýÿõíðÿ×¸Æÿ¯pŒÿ¢Y{ÿ¨dƒÿ§a‚ÿ¦aÿ¦`þ§`þ¦_û¨`ÿ­c…ÿ¦`¬«gˆ^¿€x¼{™»Ä~žÿ½y™ÿºv•û¸v”ÿ¸v•ÿ¸u”ÿ¸u”ÿ¸v”ÿ²j‹ÿ¼~šÿÜÀÌÿöîòÿþþþÿÿÿÿÿøòõÿÞÁÏÿ»€›ÿ­g‰ÿ±nŽÿ±lŒÿ°lŒÿ¯k‹ÿ¯k‹ÿ¯jŠÿ®jŠÿ¯k‹ÿ§_ÿµv’ÿÛ¿Íÿöñôÿÿÿÿÿÿÿÿÿõïòÿ×¸Èÿ°qÿ£Z{ÿ©e„ÿ¨bƒÿ§a‚ÿ§`‚þ§a‚þ¦a€û©a‚ÿ®d†ÿ§a‚­©i†_½€x¼{™»Ä~žÿ½y™ÿºv•û¸v”ÿ¸v”ÿ·u”ÿ¸u”ÿ¸v”ÿ²j‹ÿ»}šÿÜ¿ÌÿõîòÿþþÿÿÿÿÿÿíÜãÿÏ¥¸ÿ·x–ÿ¯i‹ÿ±nŽÿ±mŒÿ°l‹ÿ¯kŠÿ¯k‹ÿ®jŠÿ®jŠÿ®kŠÿ§_ÿ´v’ÿÛ¿Íÿöñôÿÿÿÿÿÿÿÿÿõïòÿ×¸Èÿ°qÿ£Z|ÿ©e„ÿ¨b‚ÿ§a‚ÿ§`‚þ§`‚þ¦_€û¨a‚ÿ®d†ÿ§a‚­©i†_¿‚Ÿx¼|š»ÅŸÿ½zšÿ»w–û¹w•ÿ¹w•ÿ¸v•ÿ·v•ÿ¹w•ÿ²kŒÿ¼~›ÿÝÁÎÿú÷øÿüùúÿèÔÝÿÍ¡µÿ»}™ÿ³pÿ²nÿ²oÿ²nÿ±mŒÿ°l‹ÿ°lŒÿ¯k‹ÿ®k‹ÿ¯lŒÿ¨`‚ÿµw“ÿÜÀÌÿöñóÿÿÿÿÿÿÿÿÿõîñÿØ¹Çÿ±pŽÿ¤[}ÿªf…ÿ©cƒÿ¨bƒÿ¨aƒþ¨aƒþ§aû©bƒÿ¯e‡ÿ¨cƒ­¬k‰_Á‚Ÿx¾|›»Å ÿ¾{›ÿ»y—ûºw–ÿºw–ÿ¹w•ÿ¸v”ÿ¸w–ÿ³lÿ½€œÿÝÀÍÿóéíÿéÔÝÿÊš°ÿ´s‘ÿ±kŒÿ³mŽÿ´qÿ²nŽÿ²oŽÿ²nÿ±mŒÿ±mŒÿ°lŒÿ¯l‹ÿ°mŒÿªa‚ÿ¶x”ÿÝÁÍÿ÷òôÿÿÿÿÿÿÿÿÿöîòÿÙºÈÿ²qÿ¥\~ÿ«g†ÿ©d„ÿ©cƒÿ©bƒþ©b„þ¨b‚ûªb„ÿ°eˆÿªc…­®kŒ_Á‚Ÿx¾|›»Å ÿ¿{›ÿ»y—û¹w–ÿºw–ÿ¹v•ÿ¸v”ÿ¸w–ÿ´nŽÿ½€œÿ×²ÃÿÙ¸ÈÿÇ”¬ÿ·v•ÿ±lŒÿ³oÿ´pÿ´pÿ²nŽÿ²oŽÿ±nÿ°mŒÿ±mŒÿ°l‹ÿ¯l‹ÿ°mŒÿªa‚ÿ¶x”ÿÝÁÎÿ÷òôÿÿÿÿÿÿÿÿÿöîòÿÙºÈÿ±qÿ¥\~ÿ«g†ÿ©d„ÿ¨cƒÿ¨bƒþ©bƒþ¨b‚ûªb„ÿ°e‡ÿªc…­®kŒ_¿„¢x¿}›»Æ€¡ÿÀ|œÿ¼z˜ûºx—ÿ»x—ÿºw–ÿ¹v•ÿ¹v•ÿ·r’ÿ»{™ÿÆ‘©ÿÂŠ¤ÿ·u”ÿ´oÿ´pÿµs’ÿµq‘ÿ´pÿ³oÿ³pÿ²oŽÿ±nÿ²nÿ±mŒÿ±m‹ÿ±nŒÿªbƒÿ·y•ÿÞÁÏÿøñõÿÿÿÿÿÿÿÿÿõïòÿØ»Éÿ²rÿ¦]ÿ¬h‡ÿªe…ÿ©d„ÿ©c„þªc„þ©cƒû«d…ÿ±fˆÿ¨dƒ­¬nŒ_Á„Ÿx¿»Ç¢ÿÁ}ÿ½{™û»y˜ÿ»y˜ÿ»x—ÿºw–ÿºw–ÿ¹v•ÿ¸u•ÿ·s’ÿµq‘ÿµr‘ÿ¶t’ÿ¶t’ÿµr‘ÿµr‘ÿµq‘ÿ´pÿ´pÿ³pÿ²oŽÿ²oŽÿ²nÿ±nŒÿ²oÿ«c…ÿ¶z–ÿÝÀÎÿ÷òôÿÿÿÿÿÿÿÿÿöîòÿÙºÈÿ³s‘ÿ¦^€ÿ¬iˆÿ«f†ÿªe…ÿªd…þªd…þ©dƒû«e…ÿ±g‰ÿªf…­®n‰_Á„Ÿx¿»Ç¢ÿÂ}œÿ½{™û»y˜ÿ»y˜ÿºx—ÿ¹w–ÿºw–ÿºw–ÿ¸u”ÿ¶q‘ÿ´oÿµq‘ÿ¶t“ÿ¸v”ÿ¶t’ÿ¶s’ÿµr‘ÿ´pÿ´pÿ³oÿ²nŽÿ²oŽÿ±nÿ±nÿ±oÿ«c…ÿ¶z–ÿÞÁÏÿøòõÿÿÿÿÿÿÿÿÿöîòÿÙºÈÿ²sÿ¦]ÿ¬h‡ÿ«f†ÿªe…ÿªd…þªd…þ©dƒû«e…ÿ±g‰ÿªf…­®n‰_Ä†¢xÀ€ž»È‚£ÿÁ~ÿ¾|šû¼z™ÿ¼z™ÿ»y˜ÿºx—ÿºx—ÿ¸u”ÿ»z˜ÿÃŠ¥ÿÂŠ¤ÿº{™ÿ´oÿ³kÿ´oÿµq‘ÿ¶s’ÿµs‘ÿ¶s’ÿ´q‘ÿ´pÿ´pÿ²pÿ±pÿ²pŽÿ­d†ÿ¸{—ÿÞÁÏÿøñôÿÿÿÿÿÿÿÿÿõîñÿÚ»Èÿ³t‘ÿ§^€ÿ­iˆÿ¬g‡ÿ«f†ÿ«e†þ«e†þªe„û¬f†ÿ²hŠÿ«f†­¬qŒ_Á„¤xÀ€»È„£ÿÁžÿ¾}šû½{™ÿ½{šÿ¼z™ÿ»y˜ÿ»z™ÿ¶r’ÿ¾žÿÓ«¾ÿÛ»ÊÿÑ§»ÿÄŒ¦ÿ»{™ÿ·v”ÿ´qÿ´pÿ³oŽÿ³oŽÿ²nŽÿ³nŽÿ³oÿ²oŽÿ±oŽÿ²oŽÿ¬b…ÿ·y•ÿÝÁÎÿ÷ñôÿÿÿÿÿþþþÿöïòÿÛ¼Éÿ´u’ÿ¨_ÿ®j‰ÿ¬hˆÿ¬g‡ÿ¬f‡þ¬f‡þ«f…û­g‡ÿ³i‹ÿ«gˆ­®qŽ_Á„¢xÀ€»È„£ÿÂžÿ¾}šû¼{™ÿ½{™ÿ¼z™ÿ»z™ÿ¼{™ÿ¶q’ÿ¿ƒŸÿÞ¿ÎÿôìðÿöîòÿéÕÞÿÙ´ÅÿÊš°ÿ¾‚žÿ·u”ÿ´oŽÿ²lÿ²mÿ³oŽÿ³pÿ³oÿ²oÿ³qÿ¬d†ÿ¸z—ÿßÃÑÿøóöÿÿÿÿÿþþþÿöîòÿÚºÉÿ´u“ÿ¨_ÿ®j‰ÿ¬g‡ÿ«g‡ÿ«f‡þ¬f‡þ«f…û­g‡ÿ³i‹ÿ«g†­®qŽ_Ä†¤xÂ‚ž»É„¤ÿÃ€Ÿÿ¿~›û½|šÿ¾|šÿ½{šÿ½{™ÿ½|™ÿ·q‘ÿÀ„ ÿáÄÑÿûøùÿÿÿÿÿýüüÿôêîÿêØàÿàÂÏÿÕ¯ÁÿÍž³ÿÄŽ¨ÿ¾‚Ÿÿ¹z—ÿ¶t’ÿ´oÿ±kŒÿ±mŒÿ²nŽÿÅ‘©ÿê×àÿüúûÿþþþÿþþþÿóêîÿÖ´Ãÿ³s‘ÿ©a‚ÿ¯kŠÿ­hˆÿ¬hˆÿ¬gˆþ­gˆþ¬g†û®hˆÿ´jÿ¬iˆ­±nŒ_Æˆ¦xÃƒ »Ê…¥ÿÄ€ ÿÀ}œû¾}›ÿ¾}›ÿ¾|šÿ¾|˜ÿ¾}šÿ¸r’ÿÀƒ¡ÿßÂÏÿ÷ðòÿþüýÿþþþÿÿÿÿÿÿÿÿÿýüüÿöïòÿíÝåÿãÊÖÿÙ¸ÈÿÓ©½ÿÌž´ÿÈ—­ÿÅ‘¨ÿÄ¨ÿËž³ÿßÂÏÿ÷ðòÿÿÿÿÿÿÿÿÿÿÿÿÿíàåÿÌ¡´ÿ±oŽÿ«c„ÿ®j‹ÿ®i‰ÿ­hˆÿ­gˆþ­h‰þ¬h‡û¯i‰ÿ´lÿ¬i‰­±nŽ_Æ†¦xÃ‚ »Ê†¥ÿÄ€ ÿÀ}œû¾}›ÿ¾}›ÿ½|šÿ¾|™ÿ¾}šÿ¸r’ÿÀ„¡ÿàÂÐÿ÷ñôÿþþþÿÿÿÿÿþþÿÿÿÿÿÿÿÿÿÿýüýÿýûüÿúøúÿùô÷ÿ÷ïóÿóêîÿðäêÿîàæÿîàçÿòèíÿùôöÿýüüÿýýýÿþýþÿþþþÿáÉÕÿ¾† ÿ¯jŠÿ­gˆÿ¯k‹ÿ®i‰ÿ­hˆÿ­gˆþ­gˆþ¬g†û®iˆÿ´lÿ¬iˆ­±nŽ_Äˆ¤xÂƒ »Ë‡¦ÿÅ¡ÿÁ~û¿~œÿ¿~œÿ¾}›ÿ½}›ÿ¿~›ÿ¹s“ÿÁ…¡ÿáÂÑÿøñõÿþþþÿþþþÿýüýÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿþþþÿÿÿÿÿÿÿÿÿñåëÿÎ¥¹ÿ²qÿ®h‰ÿ¯l‹ÿ®j‹ÿ¯jŠÿ®i‰ÿ®h‰þ®h‰þ­h‡û¯j‰ÿµlÿ®j‰­´q‘_ÆŠ¦xÃ„¡»Ë‡§ÿÅ‚¡ÿÁ€žûÀ~ÿÀ~ÿ¿~œÿ¾~œÿ¿œÿ¹t”ÿÂ†¢ÿàÃÐÿøðôÿÿÿÿÿÿÿÿÿýüüÿüøùÿúõ÷ÿû÷øÿýûüÿþýýÿþýýÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿþÿÿÿþÿÿÿþýýÿýûüÿóéíÿÖ³Äÿ¼œÿ®j‰ÿ¯jŠÿ±nÿ¯kŠÿ¯k‹ÿ¯jŠÿ¯iŠþ¯iŠþ®iˆû°jŠÿ¶mÿ¯j‹­±q‘_ÆŠ¦xÃƒ¡»Ë‡§ÿÅ‚¡ÿÁ€û¿~œÿÀ~ÿ¿}œÿ¾}œÿ¿~œÿ¹t”ÿÂ†¢ÿáÃÐÿøðôÿÿÿÿÿÿÿÿÿúö÷ÿîÞåÿßÂÐÿãÇÔÿïàçÿõîñÿûöøÿýüýÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿþþþÿøñôÿéÕÞÿÒ«½ÿ»›ÿ±lÿ±lŒÿ±mŒÿ±mŒÿ¯kŠÿ¯k‹ÿ®jŠÿ®iŠþ¯iŠþ®iˆû°jŠÿ¶mÿ¯j‹­±q‘_Èˆ¨xÄ„¢»Ìˆ§ÿÆƒ¢ÿÂžûÀÿÁžÿÀ~ÿÀ~œÿÀÿºu•ÿÃ‡£ÿàÄÑÿøñóÿÿÿÿÿÿÿÿÿùóõÿäÊÖÿÈ”¬ÿÄŒ¦ÿÐ¢¸ÿÕ®ÀÿÛ¹ÉÿßÂÐÿãÊÕÿæÏÙÿèÒÜÿçÒÛÿåÎØÿàÄÑÿ×²ÃÿÈ—®ÿ¹|˜ÿ±l‹ÿ°k‹ÿ²oŽÿ²nÿ±mŒÿ°l‹ÿ°lŒÿ¯k‹ÿ¯j‹þ°j‹þ¯j‰û±k‹ÿ·nÿ®l‹­´s”_ÈŠ¦xÄ†¢»Í‰¨ÿÇ„£ÿÃ‚ ûÁ€žÿÁ€ŸÿÁžÿÁÿÁ€žÿ»v–ÿÄˆ£ÿáÃÒÿøñôÿÿÿÿÿÿÿÿÿùóöÿáÅÒÿ¿‚žÿ²jŒÿ¸t•ÿ¹v•ÿ»|šÿ¿‚ŸÿÂ‰£ÿÅ¨ÿÆ‘ªÿÆ‘©ÿÃŒ¦ÿ½‚ÿ·u“ÿ³mÿ²mŽÿ³pÿ³qÿ²nÿ²oŽÿ²nÿ±mŒÿ±mŒÿ°lŒÿ°kŒþ°kŒþ¯kŠû²lÿ·o‘ÿ¯mŒ­·q‘_ÈŠ¦xÄ†¢»Ì‰©ÿÆ„£ÿÃ‚ ûÁ€žÿÁ€žÿÀÿÁÿÁ€žÿ»v–ÿÃˆ£ÿáÃÒÿøñôÿÿÿÿÿÿÿÿÿøòõÿâÇÓÿÀƒ ÿµnÿ¹v–ÿ¸u”ÿ·t”ÿ·t“ÿ¸u”ÿ·u“ÿ·t“ÿ·u”ÿ¶t“ÿ¶s‘ÿµpÿ´pÿ³pÿ´pÿ³pÿ²oŽÿ²oŽÿ±nÿ°mŒÿ±mŒÿ°l‹ÿ°k‹þ°kŒþ¯kŠû²lÿ·o‘ÿ¯lŒ­·q”_ÊŒ¦xÆ‡¤»ÍŠªÿÇ…¤ÿÄƒ¡ûÂŸÿÂŸÿÁ€žÿÀ€ÿÂŸÿ¼w—ÿÄ‰¤ÿâÄÓÿøñôÿÿÿÿÿÿÿÿÿùóöÿãÈÔÿÃ‡£ÿ¸s”ÿ¼|›ÿ»z˜ÿºx—ÿ¸u”ÿ¸t”ÿ¶s“ÿµpÿ²kŒÿ±hŠÿ²j‹ÿ³kŒÿ³nŽÿ³pÿ´r‘ÿµqÿ³oÿ³oÿ²oŽÿ±nÿ²nÿ±mŒÿ±lŒþ±lþ°l‹û²mŽÿ¸p’ÿ±mŒ­·s‘_ÊŒ¨xÆ‡¥»Î‹«ÿÈ†¥ÿÄƒ¢ûÃ‚ ÿÃ‚ ÿÂŸÿÁžÿÂ‚Ÿÿ¼x˜ÿÅŠ¥ÿãÅÒÿøñóÿÿÿÿÿÿÿÿÿùòöÿâÇÔÿÃ‡¢ÿ¸r’ÿ¼{šÿ»y˜ÿ»x—ÿºw–ÿºx–ÿ¹x–ÿ¼}šÿÁ‡¢ÿÂ‰£ÿÀ‡¢ÿÀ‡¢ÿ¼€œÿ¶v”ÿ³qÿ´pÿ´pÿ´pÿ³oÿ²oŽÿ²oŽÿ²nÿ²mþ²mþ±mŒû³nÿ¹q’ÿ²oŒ­´v”_ÊŒ¦xÆ‡¤»Î‹«ÿÈ†¥ÿÄƒ¢ûÂ‚ ÿÃ‚ ÿÂŸÿÁŸÿÂ‚Ÿÿ¼w—ÿÅŠ¤ÿãÄÒÿøñóÿÿÿÿÿÿÿÿÿùòöÿâÇÔÿÃ‡¢ÿ¸r’ÿ¼{™ÿ»y˜ÿ»x—ÿºw–ÿºx–ÿ¹u”ÿÃ‹¥ÿÛºÉÿæÏÙÿæÑÛÿçÒÜÿÛ»ÊÿÈ”¬ÿ¶u“ÿ²mÿµr‘ÿ´pÿ³oÿ²nŽÿ²oŽÿ±nÿ±mþ²mþ±m‹û´nŽÿ¹q’ÿ²oŽ­±v”_ÌŽ¨xÇˆ¥»ÏŒ¬ÿÉ‡¦ÿÅ„£ûÃƒ¡ÿÄƒ¡ÿÃ‚ ÿÃ‚ ÿÃƒ ÿ¾x˜ÿÆ‰¥ÿâÅÓÿ÷ðôÿÿÿÿÿÿÿÿÿùóöÿãÈÕÿÃˆ£ÿ¹s“ÿ½|šÿ¼z™ÿ»y˜ÿºy—ÿºy˜ÿ¸s“ÿÀ†¡ÿÝ½ËÿôëïÿýüýÿüüüÿõíñÿàÄÒÿÀˆ¢ÿ³nŽÿ´r‘ÿ´pÿ´pÿ³oÿ³pÿ²oŽÿ²nŽþ³nŽþ²nŒûµoÿºr“ÿ±o­´s”_Ê‘ªxÈŠ¦»Ñ¬ÿÊˆ¦ÿÆ…¤ûÄ„¢ÿÄ„¢ÿÄƒ¡ÿÄƒ ÿÄ„¡ÿ¿y™ÿÇŠ¦ÿãÆÔÿøñõÿÿÿÿÿÿÿÿÿùôöÿäÉÕÿÄ‰¤ÿ¹t”ÿ½}›ÿ½{šÿ¼z™ÿ»z˜ÿ»y™ÿ¸t”ÿ¹y–ÿÊ—®ÿèÓÝÿþýýÿþþþÿÿÿÿÿôíðÿÔ­¿ÿ»}šÿ³oÿ³oÿµr‘ÿ´pÿ´pÿ³pÿ³oþ³oþ²oûµpÿºs”ÿ²p­¹v‘_ÊŽªxÇŠ¦»Ò¬ÿÊ‡¦ÿÆ„£ûÄ„¡ÿÄ„¢ÿÃƒ¡ÿÄƒ ÿÄ„¡ÿ¿y™ÿÆŠ¦ÿãÆÔÿøñõÿÿÿÿÿÿÿÿÿùôöÿãÉÕÿÄ‰¤ÿ¹t”ÿ½}›ÿ½{™ÿ¼z™ÿ»z˜ÿ»y™ÿ»y—ÿ¸v“ÿ¼|šÿ×²Äÿõìñÿýýýÿÿÿÿÿüûûÿê×àÿËš±ÿµpÿ³oÿµt’ÿ´pÿ´pÿ³oÿ³nþ³oþ²oûµpÿºs”ÿ²p­·v‘_Î’«wÊŠ§ºÑŽ­ÿËˆ§ÿÇ…¤ûÆ†£þÆ†¤þÄ„¢ÿÃ„¡ÿÄ…¢ÿ¿zšÿÇ‹§ÿãÆÓÿøðôÿþýýÿþýýÿøòôÿäÈÕÿÄ‰¥ÿºu•ÿ¾}œÿ¾|šÿ½{šÿ¼z™ÿ¼z˜ÿ¼{™ÿ¹u•ÿ·r’ÿÈ”­ÿæÏÚÿú÷ùÿýüüÿýüüÿøóõÿÙ¶Æÿºz—ÿ´pÿµr‘ÿµq‘ÿµq‘ÿ´pÿ´oþ´pþ³pŽû¶q‘ÿ»s•ÿ³r‘¬¶w•^Î“¬xÊ‹¨»Ò¯þË‰¨ÿÇ†¥ûÆ…£ÿÆ†£ÿÅ…£ÿÄ…£ÿÅ†£ÿÀ{›ÿÈŒ¨ÿäÈÔÿøóöÿÿÿÿÿÿÿÿÿùõ÷ÿåÊ×ÿÅŠ¦ÿ»v–ÿ¿~ÿ¾}›ÿ¾|šÿ½{™ÿ½{™ÿ¼|šÿºw—ÿ¹v•ÿÀƒŸÿ×²ÃÿøòöÿÿÿÿÿÿÿÿÿÿÿÿÿæÑÚÿÅ©ÿ¶s’ÿ´oÿ¶s’ÿµr‘ÿ´qÿµp‘þµp‘þ´pû·q’ÿ½t—þ´q’­·y–_Î’«wÊŠ©ºÓ¯þË‰¨ÿÇ†¥ûÅ…£ÿÆ…£ÿÅ„¢ÿÄ…£ÿÅ†¤ÿÀ|œÿÉ©ÿäÈÕÿùóöÿÿÿÿÿÿÿÿÿúöøÿåËØÿÅŒ¦ÿ»v–ÿ¿~ÿ¾}›ÿ½|šÿ¼{™ÿ½{™ÿ¼|šÿ»y˜ÿ»y˜ÿºw–ÿÌ›²ÿñåëÿÿÿÿÿÿÿÿÿÿÿÿÿðãéÿÑ§ºÿ¹x–ÿ³mŽÿ¶t“ÿµr‘ÿ´qÿ´pþ¶p‘þ´pû·q’ÿ½t—þµq‘¬¸w•^Í’ªuÊ‹©¸Õ‘±üÍ‹ªþÉˆ¦úÇ‡¥þÇ‡¥þÇ†¤þÆ„¢ÿÆ†£ÿÁ~ÿÈ‹¨ÿÞºÊÿïÞåÿõêïÿôêïÿïßçÿß¼ÍÿÅ‰¤ÿ½x˜ÿÀžÿ¿~œÿ¾}›ÿ½|šÿ¾|šÿ½{™ÿ¼z™ÿ¼{™ÿ¹t•ÿÃŠ¥ÿâÆÓÿðåêÿóèíÿòçíÿéÔÞÿÒ¨¼ÿºz˜ÿ³nÿ·u”ÿ¶s’ÿ¶r’þµq‘þµr’ý¶q‘ú¹r“þ½u—ý¶r’ªºz–\Ï‘¬_ËŒª­Ô°ÿÍŒªÿÉˆ¦úÉˆ¦ýÉˆ¦ýÇ†¤ÿÇ†¤þÇ†£þÄ þÇˆ¦þÒ ·þÛ³ÆþÞºËþÝ¹ÊþÛ²ÅþÒ ·þÄ…£þÀ{›þÁ~žþÁ~žþÀ~þ¿}œþ¿}œþ¿|›þ½{šþ½|™þ»w—þ¿žþÍ´þÕ®ÁþØ´ÄþØ³ÅþÓ©¾þÈ”¬þºy˜þ¶q’þ¸t”þ¸t”þ¶s’ÿ¶s’ý´s‘ý´qû¹s“ÿ¼u–ÿµr’Ÿ»~—GÏ•­5ÌŒªÎŒªÿÍŒªüÉ‰¥úÉˆ¦ýÉˆ¦ýÆ†¤ÿÇ†¤þÇ†¤þÆ…£þÆ…£þÇˆ¥þÇ‰¦þÇˆ¥þÆˆ¥þÅ†¤þÃ…¡þÃ‚ þÁžþÁ~žþÁ~žþÀ}þ¿|œþ¿}œþ¾|›þ½{šþ½|šþ½z™þ¼z™þ½|›þ½}œþ¾~œþ¾}œþ¼|›þºz˜þºw–þ¸u”þ¸t•þ¸t”þ¶s’ÿ¶s’ýµr‘ý´rû¶s’ý·r“ú¶s’¼€–"ÌˆªÊ©\Ë‹¨ÜÑŽ­ÿÑ¬ÿÈˆ§ûÉ‰¦úÇ‡¦ûÆ†¥ûÇ†¥ûÇ†¤ûÅ„¢ûÄ‚ ûÂ~ûÀ|œûÀ|œûÀ|›ûÀ~œûÂžûÂžûÀûÁžûÁ~ûÀ}œûÀ~œû¾}›û½|šû½|šû¾|™û½z˜ûºv–û¸s“û·q‘û·q‘û·q‘û·s’û¹v•û¹w”û·u“û¸v”û·t“û¸s“ú·s‘û¼w—ÿ¹t•ÿ¶u“Í·v–N¶m’    È‘¬%Ì«ˆË‹©áÐŽ­üÊŠ¨ÿÌŒªÿÌ‹©ÿËŠ¨ÿËŠ¨ÿË‰§ÿÊˆ§ÿËŠ§ÿÊ‰§ÿÉ‰§ÿÉ‰§ÿÉ‡¦ÿÈ†¤ÿÇ…£ÿÆƒ¢ÿÅƒ¡ÿÅƒ¢ÿÅ‚¡ÿÄ ÿÄ ÿÃŸÿÂ€žÿÂ€žÿÂÿÁ~œÿÂžÿÁ~žÿÀ~ÿÀ}ÿÀ|›ÿ¾zšÿ¾z™ÿ½y˜ÿ¼y—ÿ¼x˜ÿ»x—ÿ»w–ÿ¸t“ÿ¼w—ú·s“Ù·w“x½„¡        ªUªÑª'Ì«}Í­ÌÊ‹©ûÒ¯ÿÓ¯ÿÒ®ÿÒ®ÿÒ­ÿÐ¬ÿÑ¬ÿÐ«ÿÏŒªÿÏŒ«ÿÎ‹ªÿÍŠ©ÿÎ‰©ÿÍˆ¨ÿÌ‡§ÿÌ‡§ÿË†¦ÿÊ…¥ÿË†¦ÿÊ…¥ÿÉ„¤ÿÉ…¤ÿÈ„£ÿÇƒ¢ÿÈƒ¢ÿÇ‚¢ÿÆ¡ÿÆ¡ÿÅ€ ÿÄŸÿÅ~ŸÿÄ~ÿÃ~ÿÂ}œÿÁ}œÿÀ{šÿ¸v•÷ºw–Ã¹x—qµs”ÿÿÿ   ÿÿÿ        Ê•°Ë‹¨OÌŒª~Ë«Ê‹¨¬É‰¦¯Èˆ¥°Èˆ¥¯Å…¤°Æ…¤°Å…¢°Å„¡°Å„¢°Ä‚¡°ÂŸ°Ä¡°ÂŸ°ÁŸ°ÁŸ°Áž°Á~œ°Áœ°¿~œ°¾}œ°¾~œ°¾}›°¼{š°¾{š°¼{š°¼{˜°¼{˜°»z—°»y–¯¼y–¯»w–¯¸w•°¹w–¯ºz–ª»y—š»y—xµx•Hµ€•               ÿ  ÿ ÿ    ÿ  Õ™³Ð•¯FË«^ÇŠ¦dÇŠ¦dÆ‰¥cÄ…£dÄ‡£dÂ…£dÇ‚¡dÇ…¡dÄ‚¡dÂ€ždÄ€ždÂ‚œd¿‚žd¿‚¡dÂ€ždÂ}œdÂ€™d¿}žd½zžd½}žd¿zœd½x™d½xœdºz™d½z–d½z™dºx–d»x—b¾z—b¹v•c¸u–d¹y˜c¿{š[ÀAÊŠŸ        € €                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           