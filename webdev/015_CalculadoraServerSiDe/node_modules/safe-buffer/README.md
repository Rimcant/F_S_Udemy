import { Buffer } from 'buffer';

/**
 * A class representation of the BSON Binary type.
 * @public
 * @category BSONType
 */
export declare class Binary {
    _bsontype: 'Binary';
    /* Excluded from this release type: BSON_BINARY_SUBTYPE_DEFAULT */
    /** Initial buffer default size */
    static readonly BUFFER_SIZE = 256;
    /** Default BSON type */
    static readonly SUBTYPE_DEFAULT = 0;
    /** Function BSON type */
    static readonly SUBTYPE_FUNCTION = 1;
    /** Byte Array BSON type */
    static readonly SUBTYPE_BYTE_ARRAY = 2;
    /** Deprecated UUID BSON type @deprecated Please use SUBTYPE_UUID */
    static readonly SUBTYPE_UUID_OLD = 3;
    /** UUID BSON type */
    static readonly SUBTYPE_UUID = 4;
    /** MD5 BSON type */
    static readonly SUBTYPE_MD5 = 5;
    /** Encrypted BSON type */
    static readonly SUBTYPE_ENCRYPTED = 6;
    /** Column BSON type */
    static readonly SUBTYPE_COLUMN = 7;
    /** User BSON type */
    static readonly SUBTYPE_USER_DEFINED = 128;
    buffer: Buffer;
    sub_type: number;
    position: number;
    /**
     * Create a new Binary instance.
     *
     * This constructor can accept a string as its first argument. In this case,
     * this string will be encoded using ISO-8859-1, **not** using UTF-8.
     * This is almost certainly not what you want. Use `new Binary(Buffer.from(string))`
     * instead to convert the string to a Buffer using UTF-8 first.
     *
     * @param buffer - a buffer object containing the binary data.
     * @param subType - the option binary type.
     */
    constructor(buffer?: string | BinarySequence, subType?: number);
    /**
     * Updates this binary with byte_value.
     *
     * @param byteValue - a single byte we wish to write.
     */
    put(byteValue: string | number | Uint8Array | Buffer | number[]): void;
    /**
     * Writes a buffer or string to the binary.
     *
     * @param sequence - a string or buffer to be written to the Binary BSON object.
     * @param offset - specify the binary of where to write the content.
     */
    write(sequence: string | BinarySequence, offset: number): void;
    /**
     * Reads **length** bytes starting at **position**.
     *
     * @param position - read from the given position in the Binary.
     * @param length - the number of bytes to read.
     */
    read(position: number, length: number): BinarySequence;
    /**
     * Returns the value of this binary as a string.
     * @param asRaw - Will skip converting to a string
     * @remarks
     * This is handy when calling this function conditionally for some key value pairs and not others
     */
    value(asRaw?: boolean): string | BinarySequence;
    /** the length of the binary sequence */
    length(): number;
    toJSON(): string;
    toString(format?: string): string;
    /* Excluded from this release type: toExtendedJSON */
    toUUID(): UUID;
    /* Excluded from this release type: fromExtendedJSON */
    inspect(): string;
}

/** @public */
export declare interface BinaryExtended {
    $binary: {
        subType: string;
        base64: string;
    };
}

/** @public */
export declare interface BinaryExtendedLegacy {
    $type: string;
    $binary: string;
}

/** @public */
export declare type BinarySequence = Uint8Array | Buffer | number[];

/**
 * BSON default export
 * @deprecated Please use named exports
 * @privateRemarks
 * We want to someday deprecate the default export,
 * so none of the new TS types are being exported on the default
 * @public
 */
declare const BSON: {
    Binary: typeof Binary;
    Code: typeof Code;
    DBRef: typeof DBRef;
    Decimal128: typeof Decimal128;
    Double: typeof Double;
    Int32: typeof Int32;
    Long: typeof Long;
    UUID: typeof UUID;
    Map: MapConstructor;
    MaxKey: typeof MaxKey;
    MinKey: typeof MinKey;
    ObjectId: typeof ObjectId;
    ObjectID: typeof ObjectId;
    BSONRegExp: typeof BSONRegExp;
    BSONSymbol: typeof BSONSymbol;
    Timestamp: typeof Timestamp;
    EJSON: typeof EJSON;
    setInternalBufferSize: typeof setInternalBufferSize;
    serialize: typeof serialize;
    serializeWithBufferAndIndex: typeof serializeWithBufferAndIndex;
    deserialize: typeof deserialize;
    calculateObjectSize: typeof calculateObjectSize;
    deserializeStream: typeof deserializeStream;
    BSONError: typeof BSONError;
    BSONTypeError: typeof BSONTypeError;
};
export default BSON;

/* Excluded from this release type: BSON_BINARY_SUBTYPE_BYTE_ARRAY */

/* Excluded from this release type: BSON_BINARY_SUBTYPE_COLUMN */

/* Excluded from this release type: BSON_BINARY_SUBTYPE_DEFAULT */

/* Excluded from this release type: BSON_BINARY_SUBTYPE_ENCRYPTED */

/* Excluded from this release type: BSON_BINARY_SUBTYPE_FUNCTION */

/* Excluded from this release type: BSON_BINARY_SUBTYPE_MD5 */

/* Excluded from this release type: BSON_BINARY_SUBTYPE_USER_DEFINED */

/* Excluded from this release type: BSON_BINARY_SUBTYPE_UUID */

/* Excluded from this release type: BSON_BINARY_SUBTYPE_UUID_NEW */

/* Excluded from this release type: BSON_DATA_ARRAY */

/* Excluded from this release type: BSON_DATA_BINARY */

/* Excluded from this release type: BSON_DATA_BOOLEAN */

/* Excluded from this release type: BSON_DATA_CODE */

/* Excluded from this release type: BSON_DATA_CODE_W_SCOPE */

/* Excluded from this release type: BSON_DATA_DATE */

/* Excluded from this release type: BSON_DATA_DBPOINTER */

/* Excluded from this release type: BSON_DATA_DECIMAL128 */

/* Excluded from this release type: BSON_DATA_INT */

/* Excluded from this release type: BSON_DATA_LONG */

/* Excluded from this release type: BSON_DATA_MAX_KEY */

/* Excluded from this release type: BSON_DATA_MIN_KEY */

/* Excluded from this release type: BSON_DATA_NULL */

/* Excluded from this release type: BSON_DATA_NUMBER */

/* Excluded from this release type: BSON_DATA_OBJECT */

/* Excluded from this release type: BSON_DATA_OID */

/* Excluded from this release type: BSON_DATA_REGEXP */

/* Excluded from this release type: BSON_DATA_STRING */

/* Excluded from this release type: BSON_DATA_SYMBOL */

/* Excluded from this release type: BSON_DATA_TIMESTAMP */

/* Excluded from this release type: BSON_DATA_UNDEFINED */

/* Excluded from this release type: BSON_INT32_MAX */

/* Excluded from this release type: BSON_INT32_MIN */

/* Excluded from this release type: BSON_INT64_MAX */

/* Excluded from this release type: BSON_INT64_MIN */

/** @public */
export declare class BSONError extends Error {
    constructor(message: string);
    get name(): string;
}

/**
 * A class representation of the BSON RegExp type.
 * @public
 * @category BSONType
 */
export declare class BSONRegExp {
    _bsontype: 'BSONRegExp';
    pattern: string;
    options: string;
    /**
     * @param pattern - The regular expression pattern to match
     * @param options - The regular expression options
     */
    constructor(pattern: string, options?: string);
    static parseOptions(options?: string): string;
    /* Excluded from this release type: toExtendedJSON */
    /* Excluded from this release type: fromExtendedJSON */
}

/** @public */
export declare interface BSONRegExpExtended {
    $regularExpression: {
        pattern: string;
        options: string;
    };
}

/** @public */
export declare interface BSONRegExpExtendedLegacy {
    $regex: string | BSONRegExp;
    $options: string;
}

/**
 * A class representation of the BSON Symbol type.
 * @public
 * @category BSONType
 */
export declare class BSONSymbol {
    _bsontype: 'Symbol';
    value: string;
    /**
     * @param value - the string representing the symbol.
     */
    constructor(value: string);
    /** Access the wrapped string value. */
    valueOf(): string;
    toString(): string;
    /* Excluded from this release type: inspect */
    toJSON(): string;
    /* Excluded from this release type: toExtendedJSON */
    /* Excluded from this release type: fromExtendedJSON */
}

/** @public */
export declare interface BSONSymbolExtended {
    $symbol: string;
}

/** @public */
export declare class BSONTypeError extends TypeError {
    constructor(message: string);
    get name(): string;
}

/**
 * Calculate the bson size for a passed in Javascript object.
 *
 * @param object - the Javascript object to calculate the BSON byte size for
 * @returns size of BSON object in bytes
 * @public
 */
export declare function calculateObjectSize(object: Document, options?: CalculateObjectSizeOptions): number;

/** @public */
export declare type CalculateObjectSizeOptions = Pick<SerializeOptions, 'serializeFunctions' | 'ignoreUndefined'>;

/**
 * A class representation of the BSON Code type.
 * @public
 * @category BSONType
 */
export declare class Code {
    _bsontype: 'Code';
    code: string | Function;
    scope?: Document;
    /**
     * @param code - a string or function.
     * @param scope - an optional scope for the function.
     */
    constructor(code: string | Function, scope?: Document);
    toJSON(): {
        code: string | Function;
        scope?: Document;
    };
    /* Excluded from this release type: toExtendedJSON */
    /* Excluded from this release type: fromExtendedJSON */
    inspect(): string;
}

/** @public */
export declare interface CodeExtended {
    $code: string | Function;
    $scope?: Document;
}

/**
 * A class representation of the BSON DBRef type.
 * @public
 * @category BSONType
 */
export declare class DBRef {
    _bsontype: 'DBRef';
    collection: string;
    oid: ObjectId;
    db?: string;
    fields: Document;
    /**
     * @param collection - the collection name.
     * @param oid - the reference ObjectId.
     * @param db - optional db name, if omitted the reference is local to the current db.
     */
    constructor(collection: string, oid: ObjectId, db?: string, fields?: Document);
    /* Excluded from this release type: namespace */
    /* Excluded from this release type: namespace */
    toJSON(): DBRefLike & Document;
    /* Excluded from this release type: toExtendedJSON */
    /* Excluded from this release type: fromExtendedJSON */
    inspect(): string;
}

/** @public */
export declare interface DBRefLike {
    $ref: string;
    $id: ObjectId;
    $db?: string;
}

/**
 * A class representation of the BSON Decimal128 type.
 * @public
 * @category BSONType
 */
export declare class Decimal128 {
    _bsontype: 'Decimal128';
    readonly bytes: Buffer;
    /**
     * @param bytes - a buffer containing the raw Decimal128 bytes in little endian order,
     *                or a string representation as returned by .toString()
     */
    constructor(bytes: Buffer | string);
    /**
     * Create a Decimal128 instance from a string representation
     *
     * @param representation - a numeric string representation.
     */
    static fromString(representation: string): Decimal128;
    /** Create a string representation of the raw Decimal128 value */
    toString(): string;
    toJSON(): Decimal128Extended;
    /* Excluded from this release type: toExtendedJSON */
    /* Excluded from this release type: fromExtendedJSON */
    inspect(): string;
}

/** @public */
export declare interface Decimal128Extended {
    $numberDecimal: string;
}

/**
 * Deserialize data as BSON.
 *
 * @param buffer - the buffer containing the serialized set of BSON documents.
 * @returns returns the deserialized Javascript Object.
 * @public
 */
export declare function deserialize(buffer: Buffer | ArrayBufferView | ArrayBuffer, options?: DeserializeOptions): Document;

/** @public */
export declare interface DeserializeOptions {
    /** evaluate functions in the BSON document scoped to the object deserialized. */
    evalFunctions?: boolean;
    /** cache evaluated functions for reuse. */
    cacheFunctions?: boolean;
    /**
     * use a crc32 code for caching, otherwise use the string of the function.
     * @deprecated this option to use the crc32 function never worked as intended
     * due to the fact that the crc32 function itself was never implemented.
     * */
    cacheFunctionsCrc32?: boolean;
    /** when deserializing a Long will fit it into a Number if it's smaller than 53 bits */
    promoteLongs?: boolean;
    /** when deserializing a Binary will return it as a node.js Buffer instance. */
    promoteBuffers?: boolean;
    /** when deserializing will promote BSON values to their Node.js closest equivalent types. */
    promoteValues?: boolean;
    /** allow to specify if there what fields we wish to return as unserialized raw buffer. */
    fieldsAsRaw?: Document;
    /** return BSON regular expressions as BSONRegExp instances. */
    bsonRegExp?: boolean;
    /** allows the buffer to be larger than the parsed BSON object */
    allowObjectSmallerThanBufferSize?: boolean;
    /** Offset into buffer to begin reading document from */
    index?: number;
    raw?: boolean;
    /** Allows for opt-out utf-8 validation for all keys or
     * specified keys. Must be all true or all false.
     *
     * @example
     * ```js
     * // disables validation on all keys
     *  validation: { utf8: false }
     *
     * // enables validation only on specified keys a, b, and c
     *  validation: { utf8: { a: true, b: true, c: true } }
     *
     *  // disables validation only on specified keys a, b
     *  validation: { utf8: { a: false, b: false } }
     * ```
     */
    validation?: {
        utf8: boolean | Record<string, true> | Record<string, false>;
    };
}

/**
 * Deserialize stream data as BSON documents.
 *
 * @param data - the buffer containing the serialized set of BSON documents.
 * @param startIndex - the start index in the data Buffer where the deserialization is to start.
 * @param numberOfDocuments - number of documents to deserialize.
 * @param documents - an array where to store the deserialized documents.
 * @param docStartIndex - the index in the documents array from where to start inserting documents.
 * @param options - additional options used for the deserialization.
 * @returns next index in the buffer after deserialization **x** numbers of documents.
 * @public
 */
export declare function deserializeStream(data: Buffer | ArrayBufferView | ArrayBuffer, startIndex: number, numberOfDocuments: number, documents: Document[], docStartIndex: number, options: DeserializeOptions): number;

/** @public */
export declare interface Document {
    [key: string]: any;
}

/**
 * A class representation of the BSON Double type.
 * @public
 * @category BSONType
 */
export declare class Double {
    _bsontype: 'Double';
    value: number;
    /**
     * Create a Double type
     *
     * @param value - the number we want to represent as a double.
     */
    constructor(value: number);
    /**
     * Access the number value.
     *
     * @returns returns the wrapped double number.
     */
    valueOf(): number;
    toJSON(): number;
    toString(radix?: number): string;
    /* Excluded from this release type: toExtendedJSON */
    /* Excluded from this release type: fromExtendedJSON */
    inspect(): string;
}

/** @public */
export declare interface DoubleExtended {
    $numberDouble: string;
}

/**
 * EJSON parse / stringify API
 * @public
 */
export declare namespace EJSON {
    export interface Options {
        /** Output using the Extended JSON v1 spec */
        legacy?: boolean;
        /** Enable Extended JSON's `relaxed` mode, which attempts to return native JS types where possible, rather than BSON types */
        relaxed?: boolean;
        /**
         * Disable Extended JSON's `relaxed` mode, which attempts to return BSON types where possible, rather than native JS types
         * @deprecated Please use the relaxed property instead
         */
        strict?: boolean;
    }
    /**
     * Parse an Extended JSON string, constructing the JavaScript value or object described by that
     * string.
     *
     * @example
     * ```js
     * const { EJSON } = require('bson');
     * const text = '{ "int32": { "$numberInt": "10" } }';
     *
     * // prints { int32: { [String: '10'] _bsontype: 'Int32', value: '10' } }
     * console.log(EJSON.parse(text, { relaxed: false }));
     *
     * // prints { int32: 10 }
     * console.log(EJSON.parse(text));
     * ```
     */
    export function parse(text: string, options?: EJSON.Options): SerializableTypes;
    export type JSONPrimitive = string | number | boolean | null;
    export type SerializableTypes = Document | Array<JSONPrimitive | Document> | JSONPrimitive;
    /**
     * Converts a BSON document to an Extended JSON string, optionally replacing values if a replacer
     * function is specified or optionally including only the specified properties if a replacer array
     * is specified.
     *
     * @param value - The value to convert to extended JSON
     * @param replacer - A function that alters the behavior of the stringification process, or an array of String and Number objects that serve as a whitelist for selecting/filtering the properties of the value object to be included in the JSON string. If this value is null or not provided, all properties of the object are included in the resulting JSON string
     * @param space - A String or Number object that's used to insert white space into the output JSON string for readability purposes.
     * @param options - Optional settings
     *
     * @example
     * ```js
     * const { EJSON } = require('bson');
     * const Int32 = require('mongodb').Int32;
     * const doc = { int32: new Int32(10) };
     *
     * // prints '{"int32":{"$numberInt":"10"}}'
     * console.log(EJSON.stringify(doc, { relaxed: false }));
     *
     * // prints '{"int32":10}'
     * console.log(EJSON.stringify(doc));
     * ```
     */
    export function stringify(value: SerializableTypes, replacer?: (number | string)[] | ((this: any, key: string, value: any) => any) | EJSON.Options, space?: string | number, options?: EJSON.Options): string;
    /**
     * Serializes an object to an Extended JSON string, and reparse it as a JavaScript object.
     *
     * @param value - The object to serialize
     * @param options - Optional settings passed to the `stringify` function
     */
    export function serialize(value: SerializableTypes, options?: EJSON.Options): Document;
    /**
     * Deserializes an Extended JSON object into a plain JavaScript object with native/BSON types
     *
     * @param ejson - The Extended JSON object to deserialize
     * @param options - Optional settings passed to the parse method
     */
    export function deserialize(ejson: Document, options?: EJSON.Options): SerializableTypes;
}

/** @public */
export declare type EJSONOptions = EJSON.Options;

/**
 * A class representation of a BSON Int32 type.
 * @public
 * @category BSONType
 */
export declare class Int32 {
    _bsontype: 'Int32';
    value: number;
    /**
     * Create an Int32 type
     *
     * @param value - the number we want to represent as an int32.
     */
    constructor(value: number | string);
    /**
     * Access the number value.
     *
     * @returns returns the wrapped int32 number.
     */
    valueOf(): number;
    toString(radix?: number): string;
    toJSON(): number;
    /* Excluded from this release type: toExtendedJSON */
    /* Excluded from this release type: fromExtendedJSON */
    inspect(): string;
}

/** @public */
export declare interface Int32Extended {
    $numberInt: string;
}

declare const kId: unique symbol;

/**
 * A class representing a 64-bit integer
 * @public
 * @category BSONType
 * @remarks
 * The internal representation of a long is the two given signed, 32-bit values.
 * We use 32-bit pieces because these are the size of integers on which
 * Javascript performs bit-operations.  For operations like addition and
 * multiplication, we split each number into 16 bit pieces, which can easily be
 * multiplied within Javascript's floating-point representation without overflow
 * or change in sign.
 * In the algorithms below, we frequently reduce the negative case to the
 * positive case by negating the input(s) and then post-processing the result.
 * Note that we must ALWAYS check