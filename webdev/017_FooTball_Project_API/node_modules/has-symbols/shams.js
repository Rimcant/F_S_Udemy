om
   */
  start(start = 0): this {
    throwIfInitialized(this);
    this.s.options.start = start;
    return this;
  }

  /**
   * Sets the 0-based offset in bytes to start streaming from. Throws
   * an error if this stream has entered flowing mode
   * (e.g. if you've already called `on('data')`)
   *
   * @param end - Offset in bytes to stop reading at
   */
  end(end = 0): this {
    throwIfInitialized(this);
    this.s.options.end = end;
    return this;
  }

  /**
   * Marks this stream as aborted (will never push another `data` event)
   * and kills the underlying cursor. Will emit the 'end' event, and then
   * the 'close' event once the cursor is successfully killed.
   *
   * @param callback - called when the cursor is successfully closed or an error occurred.
   */
  abort(callback?: Callback<void>): void {
    this.push(null);
    this.destroyed = true;
    if (this.s.cursor) {
      this.s.cursor.close(error => {
        this.emit(GridFSBucketReadStream.CLOSE);
        callback && callback(error);
      });
    } else {
      if (!this.s.init) {
        // If not initialized, fire close event because we will never
        // get a cursor
        this.emit(GridFSBucketReadStream.CLOSE);
      }
      callback && callback();
    }
  }
}

function throwIfInitialized(stream: GridFSBucketReadStream): void {
  if (stream.s.init) {
    throw new MongoGridFSStreamError('Options cannot be changed after the stream is initialized');
  }
}

function doRead(stream: GridFSBucketReadStream): void {
  if (stream.destroyed) return;
  if (!stream.s.cursor) return;
  if (!stream.s.file) return;

  stream.s.cursor.next((error, doc) => {
    if (stream.destroyed) {
      return;
    }
    if (error) {
      stream.emit(GridFSBucketReadStream.ERROR, error);
      return;
    }
  