  childOperation.next(item, key, owner, root);
      }
      if (!childOperation.keep) {
        keep = false;
      }
      if (childOperation.done) {
        if (!childOperation.keep) {
          break;
        }
      } else {
        done = false;
      }
    }
    this.done = done;
    this.keep = keep;
  }
}

export abstract class NamedGroupOperation extends GroupOperation
  implements NamedOperation {
  abstract propop: boolean;
  constructor(
    params: any,
    owneryQuery: any,
    options: Options,
    children: Operation<any>[],
    readonly name: string
  ) {
    super(params, owneryQuery, options, children);
  }
}

export class QueryOperation<TItem> extends GroupOperation {
  readonly propop = true;
  /**
   */

  next(item: TItem, key: Key, parent: any, root: boolean) {
    this.childrenNext(item, key, parent, root);
  }
}

export class NestedOperation extends GroupOperation {
  readonly propop = true;
  constructor(
    readonly keyPath: Key[],
    params: any,
    owneryQuery: any,
    options: Options,
    children: Operation<any>[]
  ) {
    super(params, owneryQuery, options, children);
  }
  /**
   */

  next(item: any, key: Key, parent: any) {
    walkKeyPathValues(
      item,
      this.keyPath,
      this._nextNestedValue,
      0,
      key,
      parent
    );
  }

  /**
   */

  private _nextNestedValue = (
    value: any,
    key: Key,
    owner: any,
    root: boolean
  ) => {
    this.childrenNext(value, key, owner, root);
    return !this.done;
  };
}

export const createTester = (a, compare: Comparator) => {
  if (a instanceof Function) {
    return a;
  }
  if (a instanceof RegExp) {
    return b => {
      const result = typeof b === "string" && a.test(b);
      a.lastIndex = 0;
      return result;
    };
  }
  const comparableA = comparable(a);
  return b => compare(comparableA, comparable(b));
};

export class EqualsOperation<TParam> extends BaseOperation<TParam> {
  readonly propop = true;
  private _test: Tester;
  init() {
    this._test = createTester(this.params, this.options.compare);
  }
  next(item, key: Key, parent: any) {
    if (!Array.isArray(parent) || parent.hasOwnProperty(key)) {
      if (this._test(item, key, parent)) {
        this.done = true;
        this.keep = true;
      }
    }
  }
}

export const createEqualsOperation = (
  params: any,
  owneryQuery: any,
  options: Options
) => new EqualsOperation(params, owneryQuery, options);

export class NopeOperation<TParam> extends BaseOperation<TParam> {
  readonly propop = true;
  next() {
    this.done = true;
    this.keep = false;
  }
}

export const numericalOperationCreator = (
  createNumericalOperation: OperationCreator<any>
) => (params: any, owneryQuery: any, options: Options, name: string) => {
  if (params == null) {
    return new NopeOperation(params, owneryQuery, options, name)