import {
  isArray,
  Key,
  Comparator,
  isVanillaObject,
  comparable,
  equals
} from "./utils";

export interface Operation<TItem> {
  readonly keep: boolean;
  readonly done: boolean;
  propop: boolean;
  reset();
  next(item: TItem, key?: Key, owner?: any, root?: boolean);
}

export type Tester = (
  item: any,
  key?: Key,
  owner?: any,
  root?: boolean
) => boolean;

export interface NamedOperation {
  name: string;
}

export type OperationCreator<TItem> = (
  params: any,
  parentQuery: any,
  options: Options,
  name: string
) => Operation<TItem>;

export type BasicValueQuery<TValue> = {
  $eq?: TValue;
  $ne?: TValue;
  $lt?: TValue;
  $gt?: TValue;
  $lte?: TValue;
  $gte?: TValue;
  $in?: TValue[];
  $nin?: TValue[];
  $all?: TValue[];
  $mod?: [number, number];
  $exists?: boolean;
  $regex?: string | RegExp;
  $size?: number;
  $where?: ((this: TValue, obj: TValue) => boolean) | string;
  $options?: "i" | "g" | "m" | "u";
  $type?: Function;
  $not?: NestedQuery<TValue>;
  $or?: NestedQuery<TValue>[];
  $nor?: NestedQuery<TValue>[];
  $and?: NestedQuery<TValue>[];
};

export type ArrayValueQuery<TValue> = {
  $elemMatch?: Query<TValue>;
} & BasicValueQuery<TValue>;
type Unpacked<T> = T extends (infer U)[] ? U : T;

export type ValueQuery<TValue> = TValue extends Array<any>
  ? ArrayValueQuery<Unpacked<TValue>>
  : BasicValueQuery<TValue>;

type NotObject = string | number | Date | boolean | Array<any>;
export type ShapeQuery<TItemSchema> = TItemSchema extends NotObject
  ? {}
  : { [k in keyof TItemSchema]?: TItemSchema[k] | ValueQuery<TItemSchema[k]> };

export type NestedQuery<TItemSchema> = ValueQuery<TItemSchema> &
  ShapeQuery<TItemSchema>;
export type Query<TItemSchema> =
  | TItemSchema
  | RegExp
  | NestedQuery<TItemSchema>;

export type QueryOperators<TValue = any> = keyof ValueQuery<TValue>;

/**
 * Walks through each value given the context - used for nested operations. E.g:
 * { "person.address": { $eq: "blarg" }}
 */

const walkKeyPathValues = (
  item: any,
  keyPath: Key[],
  next: Tester,
  depth: number,
  key: Key,
  owner: any
) => {
  const currentKey = keyPath[depth];

  // if array, then try matching. Might fall through for cases like:
  // { $eq: [1, 2, 3] }, [ 1, 2, 3 ].
  if (isArray(item) && isNaN(Number(currentKey))) {
    for (let i = 0, { length } = item; i < length; i++) {
      // if FALSE is returned, then terminate walker. For operations, this simply
      // means that the search critera was met.
      if (!walkKeyPathValues(item[i], keyPath, next, depth, i, item)) {
        return false;
      }
    }
  }

  if (depth === keyPath.length || item == null) {
    return next(item, key, owner, depth === 0);
  }

  return walkKeyPathValues(
    item[currentKey],
    keyPath,
    next,
    depth + 1,
    currentKey,
    item
  );
};

export abstract class BaseOperation<TParams, TItem = any>
  implements Operation<TItem> {
  keep: boolean;
  done: boolean;
  abstract propop: boolean;
  constructor(
    readonly params: TParams,
    readonly owneryQuery: any,
    readonly options: Options,
    readonly name?: string
  ) {
    this.init();
  }
  protected init() {}
  reset() {
    this.done = false;
    this.keep = false;
  }
  abstract next(item: any, key: Key, parent: any, root: boolean);
}

abstract class GroupOperation extends BaseOperation<any> {
  keep: boolean;
  done: boolean;

  constructor(
    params: any,
    owneryQuery: any,
    options: Options,
    public readonly childre