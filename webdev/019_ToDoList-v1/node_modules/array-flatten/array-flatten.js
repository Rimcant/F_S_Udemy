length-1&&this.setState({hideNextButton:1===e.intersectionRatio}),-1!==n&&s&&s({index:n,intersectionRatio:e.intersectionRatio})}))},this._handleScroll=()=>{const{onScroll:e}=this.props,{swipeableWidth:t}=this.state;if(e&&t){const i=this._getLeftOffset(t);e({previous:this._scrollLeft,next:i}),this._scrollLeft=i}},this._handleScrollDebounce=(0,d.Z)(this._handleScroll,500),this._goToOffset=e=>{const{isLocked:t}=this.props;if(t)return;const i=this._list.current;if(i instanceof window.HTMLElement)if(n.Z.getConstants().isRTL)if(P())this._scrollToOffset(-e);else{const t=i.scrollWidth-(this.state.swipeableWidth||0);this._scrollToOffset(t-e)}else this._scrollToOffset(e);else this._scrollToOffset(e)},this._scrollToOffset=(e,t)=>{const i=this._list.current;i&&i.scrollTo&&i.scrollTo({left:e,behavior:this._getScrollBehavior(t)})},this._getLeftOffset=e=>{const t=this._list.current,i=t?t.scrollLeft:0,s=t?t.scrollWidth:0;let o=0;return o=n.Z.getConstants().isRTL?P()&&n.Z.getConstants().isRTL?-1*Math.min(0,i):-1*Math.min(0,i-(s-e)):i,Math.ceil(o)},this._goToPreviousPage=()=>{const{swipeableWidth:e=0}=this.state;this._goToOffset(this._getLeftOffset(e)-e)},this._goToNextPage=()=>{const{swipeableWidth:e=0}=this.state;this._goToOffset(this._getLeftOffset(e)+e)