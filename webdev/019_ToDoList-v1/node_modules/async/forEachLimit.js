d, implicitly closing the change stream
        if (change == null) {
            // TODO(NODE-3485): Replace with MongoChangeStreamClosedError
            throw new error_1.MongoRuntimeError(CHANGESTREAM_CLOSED_ERROR);
        }
        if (change && !change._id) {
            throw new error_1.MongoChangeStreamError(NO_RESUME_TOKEN_ERROR);
        }
        // cache the resume token
        this.cursor.cacheResumeToken(change._id);
        // wipe the startAtOperationTime if there was one so that there won't be a conflict
        // between resumeToken and startAtOperationTime if we need to reconnect the cursor
        this.options.startAtOperationTime = undefined;
        return change;
    }
    /** @internal */
    _processErrorStreamMode(changeStreamError) {
        // If the change stream has been closed explicitly, do not process error.
        if (this[kClosed])
            return;
        if ((0, error_1.isResumableError)(changeStreamError, this.cursor.maxWireVersion)) {
            this._endStream();
            this.cursor.close().catch(() => null);
            const topology = (0, utils_1.getTopology)(this.parent);
            topology.selectServer(this.cursor.readPreference, {}, serverSelectionError => {
                if (serverSelectionError)
                    return this._closeEmitterModeWithError(changeStreamError);
                this.cursor = this._createChangeStreamCursor(this.cursor.resumeOptions);
            });
        }
        else {
            this._closeEmitterModeWithError(changeStreamError);
        }
    }
    /** @internal */
    async _processErrorIteratorMode(changeStreamError) {
        if (this[kClosed]) {
            // TODO(NODE-3485): Replace with MongoChangeStreamClosedError
            throw new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR);
        }
      